# 5 微服务之间的通信

本章涵盖

+   在应用级别使用实时重载以实现更快的迭代

+   使用 HTTP 请求在微服务之间发送直接消息

+   使用 RabbitMQ 在微服务之间发送间接消息

+   在使用直接和间接消息之间进行选择

一个微服务应用由许多微服务组成，每个微服务负责其自己的领域。因为每个微服务本身都很小、简单，并且不做很多事情，所以我们的微服务必须协作以创建实现应用功能集所需复杂行为。为了协作，我们的微服务需要通信方式。如果它们不能相互交谈，那么它们将无法协调它们的活动，也不会取得很大成就。

在本章中，我们探讨了微服务之间可以采用的不同通信方式，以便它们能够协作并满足应用的高级需求。在这个过程中，我们还将回顾 Docker 和 Docker Compose，以设置整个应用的实时重载。向前推进，这是必要的，这样我们就不需要不断地重建和重新启动我们的应用，随着代码的更新。

在前面的章节中，我们已经看到 HTTP 请求是微服务之间通信的一种方式。在本章中，我们将扩展使用 HTTP 请求进行直接消息传递，同时我们还将探讨使用 RabbitMQ 进行间接消息传递。在整个章节中，你将学习如何根据具体情况决定使用哪种类型的消息传递。

## 5.1 新的和熟悉的工具

本章介绍了 RabbitMQ 软件用于消息队列。这将帮助我们解耦我们的微服务。我们将使用 npm 包 amqplib 将我们的微服务连接到 RabbitMQ，以便它们可以发送和接收消息。我们还将回顾一些熟悉工具，并更详细地探讨我们如何使用 HTTP 请求发送消息，以及如何升级我们的开发环境以支持应用级别的实时重载。

表 5.1 第五章中的新和熟悉工具

| 工具 | 版本 | 目的 |
| --- | --- | --- |
| Docker Compose | 1.26.2 | Docker Compose 允许你同时配置、构建、运行和管理多个容器。 |
| HTTP | 1.1 | 超文本传输协议（HTTP）用于从一个微服务向另一个微服务发送直接（或同步）消息。 |
| RabbitMQ | 3.8.5 | RabbitMQ 是我们将用于从一个微服务向另一个微服务发送间接（或异步）消息的消息队列软件。 |
| amqplib | 0.5.6 | 这个 npm 包允许我们配置 RabbitMQ，并从 JavaScript 发送和接收消息。 |

## 5.2 获取代码

要跟随本章内容，你需要下载代码或克隆存储库。

+   从这里下载代码的 zip 文件：

    [`github.com/bootstrapping-microservices/chapter-5`](https://github.com/bootstrapping-microservices/chapter-5)

+   你可以使用 Git 如下克隆代码：

    `git clone https://github.com/bootstrapping-microservices/chapter-5.git`

关于安装和使用 Git 的帮助，请参阅第二章。如果您对代码有问题，请在 GitHub 仓库中记录一个问题。

## 5.3 让我们的微服务开始对话

在本书的这一部分，我们有一个包含两个微服务的应用程序：视频流和视频存储。在上一章中，我们添加了数据存储功能；视频流微服务有一个数据库，视频存储微服务使用外部云存储来存储视频文件。图 5.1 显示了我们的应用程序现在的样子。

![图片](img/CH05_F01_Davis4.png)

图 5.1 我们在上一个章节中完成了两个微服务和数据库在开发工作站上运行在 Docker Compose 下的工作。在那个章节中，我们还添加了连接到 Azure 云存储以存储我们的视频。

一个微服务应用程序只能由协作以提供应用程序功能的微服务构建而成。如果我们有无法通信的微服务，我们的应用程序将无法做很多事情！因此，微服务之间的通信是构建微服务的重要组成部分，我们必须有可用的通信技术。

实际上，如果没有在第四章中像我们那样使用 HTTP 请求来在视频流和视频存储微服务之间进行通信，我们就不会走到这一步。我们在那里只是略过了这一点，但实际上它非常重要。没有它，我们就会在第一个障碍上跌倒：将我们的应用程序的流媒体和存储功能分离出来。

注意：我们的微服务必须协同工作以实现应用程序的功能，因此它们能够进行通信以协作至关重要。

在本章中，我们向我们的应用程序添加了第三个微服务：历史微服务。添加这个新微服务的目的是为了演示微服务之间的通信。您可以在图 5.2 中看到视频流微服务是如何向历史微服务发送消息流的。

图 5.2 从概念上展示了本章结束时我们的应用程序将是什么样子，但它并没有展示我们将要添加的完整技术细节。为了获得完整的图景，我们需要了解我们可以使用的各种通信风格以及支撑这些技术的技术。在此之前，让我们更好地理解历史微服务。

![图片](img/CH05_F02_Davis4.png)

图 5.2 在本章中，我们通过添加一个新的微服务来扩展我们的应用程序，并探索微服务之间的通信方法。

## 5.4 介绍历史微服务

在本章中，我们使用历史微服务作为示例，说明微服务如何相互发送和接收消息。实际上，这个新微服务在 FlixTube 中确实有一个合适的位置，正如其名称所暗示的，它记录了我们的用户的观看历史。

我们的应用程序可以通过多种方式利用这个历史记录。首先，我们的用户可能想查看自己的历史记录以记住他们以前观看的视频。他们可能希望在以后继续观看视频，或者我们可以用它来为其他用户提供推荐。

为了使本章的示例简单，我们将从上一章中删除视频存储微服务，这简化了视频流微服务。实际上，在本章的起点，我们将回到视频流微服务的早期版本，其中示例视频已经嵌入到其 Docker 镜像中。我们将像第三章之后那样使用视频流微服务。这种简化只是为了我们熟悉通信技术。在本章之后，我们将恢复视频存储微服务，并将视频流微服务恢复到其原来的状态。

我们将在微服务之间传输的消息是*已查看*的消息。这就是视频流微服务如何通知历史微服务用户已经观看了一个视频。图 5.3 展示了历史微服务正在做什么。它从视频流微服务接收一系列消息，并将它们记录在其自己的数据库中。

![图 5.3](img/CH05_F03_Davis4.png)

图 5.3 作为探索通信方法的一种方式，我们将让视频流微服务向历史微服务发送已查看的消息以记录我们的用户观看历史。

我们还没有讨论我们可以使用的消息风格——这将在不久的将来讨论。目前，请知道我们有多项技术可以用来发送已查看的消息。在本章中，我们将探讨我们的选项，我们可以在以后决定哪个最适合这种特定情况。不过，在之前，让我们升级我们的开发环境以加快开发周期。

## 5.5 快速迭代的实时重载

在 2.4 节中，我们讨论了我们的开发哲学以及为什么小而快的增量对于紧密的反馈循环和保持快速的开发节奏至关重要。在第二章中，当我们直接在 Node.js 下运行我们的第一个微服务时，我们能够使用 npm 包 nodemon 来使我们的微服务*实时重载*。这意味着当我们对其代码进行更改时，我们的微服务会自动重新加载。在应用层面，拥有高效的实时重载机制比在微服务层面更为重要。这是因为构建和启动整个应用程序比每个单独的微服务要慢得多。

在第三章中，我们使用了 Docker，并开始将我们的微服务代码“烘焙”到 Docker 镜像中。Docker 是我们打包、发布和部署微服务的极其有用的方式。这就是我们使用它的原因，尽管我们还没有看到这个谜题的部署部分。然而，为了看到部署的实际操作，我们需要一个生产环境（将在第六章中介绍），到第七章，我们将看到我们的 Docker 镜像被部署到生产环境中。

在第四章中，我们使用 Docker Compose 在我们的开发环境中作为一种方便的方式来构建和管理我们不断增长的应用程序。这一切都很好，但不幸的是，在从直接使用 Node.js 过渡到在 Docker 容器中运行我们的微服务时，我们失去了自动重新加载代码的能力。

由于我们将代码烘焙到我们的 Docker 镜像中，我们无法在之后更改它！这对于生产来说很棒，因为出于安全原因，我们真的不希望任何中间人能够篡改这段代码。现在的问题是，在开发过程中，我们不希望不断地重建我们的镜像和重新启动应用程序以包含更新的代码。这样做非常慢。而且，对于重复的重建和重启，时间真的会累积起来，尤其是随着我们的应用程序规模的扩大。

注意：无法快速更新运行中的应用程序代码对我们的开发过程来说是一件糟糕的事情，这可能会极大地消耗我们的生产力。我们将尽早解决这个问题，并找到一种方法来恢复我们的实时重新加载功能。

在本节中，我们将升级我们的 Docker Compose 文件，以支持在开发工作站和我们的容器之间共享代码。图 5.4 展示了新历史微服务的源代码目录是如何从我们的开发工作站共享到微服务的容器中的。

再次强调，我们将使用 nodemon 来完成这项工作，并且我们将将其应用于所有我们的微服务。它会在代码更改时自动重启每个微服务。这种配置可能看起来很繁琐，但将其正确设置是非常有价值的，因为它将对我们的开发速度产生重大影响！

![图 5.4](img/CH05_F04_Davis4.png)

图 5.4 为了在更大范围内启用实时重新加载，我们在开发工作站和容器之间同步我们的代码，以便代码的更改自动传播到容器中。

### 5.5.1 为历史微服务创建存根

我们只为新的历史微服务创建实时重新加载配置，但之后，我们需要将此相同的配置应用到每个微服务上。这样，我们的应用程序中的所有微服务都支持实时重新加载。

在我们开始之前，阅读列表 5.1，熟悉新生的历史微服务。目前它还没有做任何事情。它只是一个占位符，等待添加功能。一旦我们为这个微服务实现了实时重新加载，我们就能使用 Docker Compose 启动我们的应用程序。然后，我们将对新的微服务进行实时更新和增量更改，而无需重新启动应用程序。

列表 5.1 历史微服务的占位符（第五章/示例 1/历史/src/index.js）

```
const express = require("express");
function setupHandlers(app) {
                                ①
}
function startHttpServer() {
    return new Promise(resolve => {
        const app = express();
        setupHandlers(app);

        const port = process.env.PORT && 
        ➥ parseInt(process.env.PORT) || 3000;
        app.listen(port, () => {
            resolve();
        });
    });
}
function main() {
    console.log("Hello world!");
    return startHttpServer();
}
main()
    .then(() => console.log("Microservice online."))
    .catch(err => {
        console.error("Microservice failed to start.");
        console.error(err && err.stack || err);
    });
```

① 这是一个占位符微服务。稍后，我们将在这里添加 HTTP 路由和消息处理器！

### 5.5.2 为实时重新加载增强微服务

对于我们的微服务的基本代码，除了我们在第二章中学到的之外，我们不需要做任何其他的事情，包括我们设置第一个微服务和安装 nodemon 以实现实时重新加载。每个微服务都需要像这样安装 nodemon：

```
npm install --save-dev nodemon
```

npm 包 nodemon 是我们用来监控代码并在代码更改时自动重启微服务的工具。微服务的 package.json 文件中包含了一个名为 start:dev 的 npm 脚本，这是我们在第二章中开始使用的约定。你可以在列表 5.2 中看到它的样子。

列表 5.2 使用 nodemon 设置 package.json 以实现实时重新加载（第五章/示例 1/历史/package.json）

```
{
  "name": "history",
  "version": "1.0.0",
  "description": "",
  "main": "./src/index.js",
  "scripts": {
    "start": "node ./src/index.js",
    "start:dev": 
    ➥ "nodemon --legacy-watch ./src/index.js"      ①
  },
  "keywords": [],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "express": "⁴.17.1"
  },
  "devDependencies": {
    "nodemon": "¹.19.1"
  }
}
```

① 使用 nodemon 为这个微服务启用实时重新加载。当代码更改时，nodemon 会自动重启微服务。

在 start:dev npm 脚本设置到位后，我们可以这样运行我们的微服务：

```
npm run start:dev
```

这将像这样调用 nodemon 来监控我们的微服务：

```
nodemon --legacy-watch ./src/index.js. 
```

显然，你总是可以键入完整的 nodemon 命令，但使用`npm run start:dev`更短，并且对于我们的所有微服务都是一样的，前提是我们将这个约定应用到每个微服务上。如果你刚刚启动了历史微服务，现在使用 Ctrl-C 退出。不久，我们将再次使用 Docker Compose 运行我们的整个应用程序。

你可能想知道为什么我在 nodemon 中使用了`--legacy-watch`参数。我使用这个参数是因为我经常在 Linux 虚拟机（VM）下运行 Docker 和 Docker Compose。这是在 Windows Home PC 上使用 Linux 的一种方便方式。（在 WSL2 之前，Windows Home 无法直接运行 Docker。）

`--legacy-watch`参数禁用了文件系统监控，并使用频繁轮询机制来监控代码更改。如果你在虚拟机上开发，你需要这个参数，因为实时重新加载所需的自动文件监控无法从宿主操作系统传递更改。

如果你不是在虚拟机（VM）下进行开发，你可以安全地移除`--legacy-watch`参数，你的实时重新加载将会有更好的性能。你可以在附录 A 中了解更多关于在开发中使用虚拟机的内容。

### 5.5.3 为开发和生产分割 Dockerfile

在第二章，我们讨论了能够在开发模式或生产模式下运行我们的微服务。我们做出这种区分是为了能够针对开发和生产的不同需求分别进行优化。在本节中，您将看到这种分离开始实现。

注意：在此阶段，我们将为我们的开发和生产模式创建单独的 Dockerfile。在每种情况下，我们的需求都不同。对于开发，我们优先考虑快速迭代。对于生产，我们优先考虑性能和安全。

对于所有微服务，从现在起，我们将创建不止一个，而是两个 Dockerfile。我们现在需要一个用于开发，另一个用于生产。我们将开发版本的 Dockerfile 命名为 Dockerfile-dev，生产版本的 Dockerfile 命名为 Dockerfile-prod。

这些名称的选择是为了避免混淆。在软件开发中，命名非常重要，我们应该努力选择清晰的名字以帮助避免歧义。我们现在将 Dockefiles 分开，以便在开发中启用实时重载。这不是我们希望在生产中启用的事情！

列表 5.3 显示了新历史微服务的生产 Dockerfile。这里没有什么新内容，因为这基本上是一个相当标准的 Node.js Dockerfile。它与我们在第三章中创建的 Dockerfile 相似。

列表 5.3 创建生产 Dockerfile（chapter-5/example-1/history/Dockerfile-prod）

```
FROM node:12.18.1-alpine              ①
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install --only=production     ②
COPY ./src ./src                      ③
CMD npm start                         ④
```

① 我们使用 alpine Linux 镜像用于生产，因为它使我们的微服务镜像变得很小。

② 仅安装生产依赖项

③ 将源代码复制到镜像中。我们可以说代码被“烘焙”到镜像中了。

④ 以生产模式启动微服务

在本章中，我们实际上不会使用生产 Dockerfile，但在第七章，当我们部署到生产环境时，我们肯定会需要这些。将开发和生产 Dockerfile 并排维护是一个好主意，这样开发版本就不会比生产版本领先太多。

列表 5.4 显示了历史微服务的开发 Dockerfile。阅读它，并将其与列表 5.3 中的生产 Dockerfile 进行比较。自己注意开发与生产之间的差异。

列表 5.4 创建开发 Dockerfile（chapter-5/example-1/history/Dockerfile-dev）

```
FROM node:12.18.1-alpine                     ①
WORKDIR /usr/src/app
COPY package*.json ./                        ②
CMD npm config set cache-min 9999999 && \    ③
    npm install && \                         ④
    npm run start:dev                        ⑤
```

① 我们可以选择在这里使用非 alpine 版本的 Linux，而不是 alpine 版本。非 alpine 发行版更大，但它有更多在开发期间有用的调试工具。

② 将 package.json 文件复制到镜像中。请注意，我们并没有将代码复制到镜像中。

③ 启用 npm 安装的缓存，使得后续的 npm 安装更快

④ 容器启动时执行 npm install。这意味着我们可以利用 npm 缓存，使得在容器启动时安装比在构建过程中安装要快得多。

⑤ 以开发模式启动微服务，使用 nodemon 进行实时重载

你是否注意到了两个不同的 Dockerfile 之间的差异？在列表 5.3 中，我们只安装了生产依赖项，而在列表 5.4 中，我们安装了所有依赖项，包括我们的开发依赖项。但你是否注意到了最重要的变化？在列表 5.3 中，我们使用`COPY`指令将我们的代码烘焙到生产 Docker 镜像中：

```
COPY ./src ./src
```

那个命令将我们的代码复制到镜像中。在 Dockerfile 的开发版本中最有趣的是缺少的部分。你会注意到，在列表 5.4 中，我们的代码没有`COPY`指令（尽管有 package.json 的一个），因此我们排除了我们的代码从开发 Docker 镜像中！如果我们把我们的代码烘焙到镜像中，那么我们就不容易稍后更改它。如果我们不能更改我们的代码，那么我们就不能使用实时重新加载。

但如果我们没有将代码复制到我们的开发镜像中，那么它将如何进入容器呢？我们将在下一节中找到这个问题的答案。现在，我们还需要看看开发 Dockerfile 和产品 Dockerfile 之间还有一个重大差异。

注意指定如何在容器内启动我们的微服务的`CMD`指令。在产品 Dockerfile 中，我们简单地使用第二章中描述的`npm start`约定启动微服务：

```
CMD npm start
```

开发 Dockerfile 中的`CMD`指令不同，并且做了更多的工作：

```
CMD npm config set cache-min 9999999 && \
    npm install && \
    npm run start:dev
```

这个命令通过反斜杠（\）行续字符在三条线上分开。第一行配置了 npm 缓存，第二行安装了 npm，第三行启动了微服务。

在产品 Dockerfile 中，我们在 Docker 构建过程中调用`npm install`，这意味着我们的依赖项被烘焙到镜像中，正如在生产中应该的那样。然而，在开发版本中，我们在容器启动时执行`npm install`。开发中这种差异的原因是为了在后续重建中提供更好的性能。

`npm install`可能需要很长时间。当我们容器启动时执行它，我们能够在主机操作系统上缓存 npm 包。这就是为什么我们在第一行配置了缓存。以这种方式缓存我们的 npm 包使得后续的 npm 安装变得更快，这反过来又使得容器启动更快。我们将在下一节中了解更多关于它是如何工作的信息。

开发 Dockerfile 中`CMD`指令的第三行实际上是启动微服务。它调用`npm script start:dev`以启用实时重新加载来以开发模式启动我们的微服务。

### 5.5.4 更新 Docker Compose 文件以实现实时重新加载

使我们的应用程序级实时重新加载工作完成的最后部分是对我们的 Docker Compose 文件进行一些必要的更改，以在主机操作系统和容器之间共享我们的代码和 npm 缓存。在本节中，我们使用 Docker 卷在开发工作站和容器之间共享文件系统。这意味着我们可以在 Visual Studio (VS) Code 中编辑代码，并且更改几乎立即在我们的在 Docker Compose 下运行的微服务中可见。

列表 5.5 是从 example-1 Docker Compose 文件中提取的，展示了我们新历史微服务的配置。这与我们在第四章中创建的 Docker Compose 文件类似，但有一些差异和新增内容。

列表 5.5 更新 Docker Compose 文件以实现实时重新加载（第五章/example-1/docker-compose.yaml 的提取）

```
version: '3'
services:
  # ... other services defined here ...
  history:                                    ①
    image: history
    build: 
      context: ./history
      dockerfile: Dockerfile-dev              ②
    container_name: history
    volumes:                                  ③
      - /tmp/history/npm-cache:/root/.npm:z   ④
      - ./history/src:/usr/src/app/src:z      ⑤
    ports:
     - "4002:80"
    environment:
      - PORT=80
      - NODE_ENV=development
    restart: "no"
```

① 定义了我们的新历史微服务的容器

② 使用 Dockerfile 的开发版本

③ 定义了主机操作系统和容器之间共享的卷

④ 从主机共享 npm 缓存到容器中。这正是允许 npm 模块被缓存，使得后续安装更快的原因。

⑤ 直接从主机共享源代码到容器。你可以在你的开发工作站上（例如，使用 VS Code）进行更改，这些更改将自动在容器内可见。

列表 5.5 中新的第一点是，我们现在使用`Dockerfile-dev`，这是我们的 Dockerfile 的开发版本。我在第四章提到，我们可以省略`dockerfile`字段，并且它将默认为`Dockerfile`。在第四章中，我们没有将其设置为默认值；相反，我们明确将其设置为`Dockerfile`。我指出，我们将在不久的将来明确设置它。好吧，现在我们就到了这里，我们明确将其设置为`Dockerfile-dev`以使用我们的 Dockerfile 的开发版本。

接下来新的内容是添加了`volumes`字段，我们在其中创建了一些 Docker 卷来连接我们的开发工作站上的文件系统与容器的文件系统。这直接将我们的源代码链接到容器中。这也是我们没有直接将代码烘焙到镜像中的原因。

为了共享代码，我们使用一个 Docker 卷。另一个卷创建了一个用于 npm 缓存的共享目录。这允许在容器中安装的 npm 包在主机操作系统上被缓存，这样，如果我们销毁并重新创建容器，后续的 npm 安装会更快，因为我们已经保留了容器外的缓存。

如果你对列表 5.5 中卷配置中使用的`z`标志感到好奇，这仅仅是指示 Docker 该卷是要共享的（可能是在多个容器之间）。如果你愿意，你可以在这里了解更多信息：

[`docs.docker.com/storage/bind-mounts/`](https://docs.docker.com/storage/bind-mounts/)

这已经有很多东西要吸收了，到目前为止，这只是为了历史微服务！我们需要对所有微服务进行这些更改。幸运的是，我们只需使用相同的模式并将其应用于每个微服务，如下所示：

+   为每个微服务安装 nodemon。

+   更新 package.json 并实现 start:dev 脚本来使用 nodemon 启动微服务（如列表 5.3 所示）。

+   创建我们的 Dockerfile 的开发和生成版本。开发 Dockerfile 不应该将代码复制到镜像中（如列表 5.4 所示）。

+   在容器启动时执行`npm install`；仅限开发，不用于生产（这是为了性能，如列表 5.4 所示）。

+   更新 Docker Compose 文件，使其使用开发 Dockerfile（如列表 5.5 所示）。

+   在 Docker Compose 文件中添加 Docker 卷，以便将源代码和 npm 缓存共享到容器中（如列表 5.5 所示）。

我已经为第五章仓库中的所有示例都做了这件事，所以你不必担心。但你应该至少启动 example-1，然后对历史微服务进行一些代码更改，这样你就可以看到实时重新加载的效果！所以现在让我们来做这件事。

### 5.5.5 尝试实时重新加载

看代码列表已经够多了！现在是时候看到实时重新加载的效果，这样你才能真正欣赏它的有用性。打开一个终端，切换到 chapter-5 代码仓库下的 example-1 子目录。然后使用 Docker Compose 启动应用程序：

```
docker-compose up --build
```

这个例子包含了简化的视频流微服务和新的存根历史微服务。检查 Docker Compose 的输出。你应该会看到存根历史微服务启动时打印出“Hello world!”。为了测试实时重新加载，我们将更改历史微服务打印的消息：

1.  在 VS Code 中打开 example-1 目录。

1.  找到并打开历史微服务的 index.js 文件。

1.  搜索打印“Hello world!”消息的代码行，并将此代码行更改为打印“Hello computer!”。

1.  保存 index.js 文件，然后切换回 Docker Compose 输出。

如果你切换得足够快，你会看到历史微服务正在重新加载并打印你的更新消息。如果你切换得不够快，你应该看到这已经发生了。当你这样做的时候，请注意视频流微服务并没有重新加载。那是因为我们没有更改它的代码。只有历史微服务被更新了，所以只有它重新加载了。

这就是实时重新加载的承诺。我们可以快速迭代更新我们的代码并快速直接地获得反馈。我们不必等待构建和启动整个应用程序。相反，我们可以为需要更新的每个微服务*热加载*代码。

那么，如果我们代码中引入了错误会发生什么？当微服务带有错误重新加载时，我们会看到什么？错误会在 Docker Compose 输出中显示。然后我们可以纠正错误并保存代码文件。微服务会自动重新加载，并且假设我们的更改实际上修复了错误，我们应该会看到更新后的微服务的干净输出。

到目前为止，我实际上建议你尝试破坏历史微服务，看看会发生什么。继续。打开它的 index.js 文件，输入一些肯定会导致它崩溃的随机胡言乱语。保存文件，然后切换回 Docker Compose 输出以查看结果。

问问自己错误信息是什么意思，我做了什么导致了它？现在我听到你说，“但是 Ash，我们希望保持代码的正常工作，那么我们为什么要尝试破坏它？”

实际上，在受控和安全的环境中练习破坏和修复代码是很好的。这样，当遇到野外真实问题时，你会更有经验，并且对错误信息和如何处理这些问题会有更好的理解。现在花点时间破坏代码；造成问题，并在过程中找点乐趣。

强制容器重新启动

有时我们可能想要强制重新加载一个没有更改的微服务。比如说，微服务已经挂起或崩溃，现在卡住了。使用我们的实时重新加载系统，我们可以通过更改代码来简单地使容器重新启动，例如，添加一些空白字符，然后保存文件。

实际上，我们甚至不需要走那么远。我们只需在 VS Code 中保存文件就足够了，这样就可以使容器重新启动。我们不需要做出更改！

如果你可以从终端访问`touch`命令，你也可以像以下这样从命令行触发历史微服务的实时重新加载：

```
cd chapter-5/example-1
touch history/src/index.js
```

如果你还没有为特定容器设置实时重新加载（你实际上只需要为代码频繁更改的微服务使用实时重新加载），那么你可以使用 Docker Compose 的`restart`命令来使容器重新启动；例如，要强制历史微服务重新启动，请输入

```
docker-compose restart history
```

### 5.5.6 在开发中测试生产模式

到目前为止，在本章中，我们已经将我们的 Dockerfile 拆分为单独的文件，以便我们可以为开发模式和生产模式拥有不同的版本，但我们还没有使用生产 Dockerfile。这将在第七章中改变，当我们部署到生产环境时。现在，只需注意，我们不会像在开发期间那样频繁地在生产模式下测试我们的应用程序。

在开发过程中，我们将不断进行小的增量代码更改，然后测试我们的应用程序是否仍然正常工作。尽管我们并不像开发版本那样频繁地使用我们的生产 Dockerfile，但我们仍然应该与开发版本一起更新这些文件。我们还应该定期在生产环境中进行测试，尽管不如开发期间频繁。

例如，你可能每几分钟就在开发模式下进行一次测试，因为你正在修改代码。你仍然想测试生产模式，但也许，你只有在积累了大量代码更改之后，每隔几个小时才进行一次。主要观点是，在你将这些部署到生产之前，你也需要测试你的生产 Dockerfile。你不想无意中积累隐藏的问题，这些问题只有在部署到生产后才会暴露出来。

你可以通过在开发工作站上定期以生产模式进行测试来轻松且主动地解决这个问题。通常，我会做的是有两个单独的 Docker Compose 文件：一个用于开发，另一个用于生产。

当你调用 Docker Compose 时，可以使用 `-f` 参数来指定 Docker Compose 文件。例如，如果你想在你开发工作站上以生产模式运行你的应用程序，你可能想创建一个单独的 *生产* 版本的 Docker Compose 文件并像这样运行它：

```
docker-compose -f docker-compose-prod.yml up --build
```

你可以有一个单一的 Docker Compose 文件，该文件由环境变量参数化，但通常我会为测试开发和生产保留不同的版本。这是因为我喜欢让我的生产 Docker Compose 文件尽可能地模仿真实的生产环境。此外，通常我的开发版本会用模拟版本替换各种微服务，以便更容易和更快地进行测试。

我们将在第九章中讨论模拟微服务。在第八章中，我们将介绍自动化测试，这是可以增强你生产力的另一个方面。

### 5.5.7 我们取得了什么成果？

在第 5.5 节中，我们为我们的微服务配置了实时重新加载。我们从历史微服务开始，并将相同的模式应用到视频流微服务上。从现在起，我们将为此使用所有我们的微服务。

我们这样做是因为构建和启动我们的应用程序需要花费相当多的时间。我们不希望每次更改代码时都构建和重新启动我们的应用程序。相反，我们希望能够快速更改代码以进行实验和快速迭代，并让应用程序自动更新自己。现在，我们可以编辑代码，我们的微服务将自动重启。这就是为什么这被称为 *实时重新加载--* 它在你编码时自动重新加载。

这使得工作流程非常高效和有效。我们现在可以持续演进我们的微服务应用程序，同时接收持续的反馈流。浏览 example-1 中的代码，确保你理解实时重新加载配置是如何在整个应用程序中应用的。

## 5.6 微服务通信方法

在升级我们的开发环境以支持应用程序范围实时重载的间歇之后，现在让我们回到本章的主题：探索微服务之间的通信机制。但在我们深入研究通信技术之前，我们将从对微服务使用的两种通信风格的高级概述开始：直接消息和间接消息，也通常称为 *同步* 和 *异步* 通信。

我更喜欢使用“直接消息”和“间接消息”这样的术语，而不是“同步消息”和“异步消息”，因为“同步”和“异步”这两个词在常规计算机编程中具有不同的含义。此外，异步编程的概念，尤其是，可能很难学习，并且让许多有志于编程的人感到寒心。不要担心；我们将避免使用“异步”这个词。

### 5.6.1 直接消息

*直接* *消息* 简单来说就是指一个微服务直接向另一个微服务发送消息，然后立即接收直接响应。当希望一个微服务直接向特定微服务发送消息并立即在其中调用动作或任务时，会使用直接消息。

直接消息也用于在另一个微服务中触发直接动作。我们还可以用它来在多个微服务之间按顺序执行一系列严格的行为。你可以将其视为向另一个微服务发送命令或指示（例如，*这样做* 或 *那样做* 然后告诉我*你是否成功*）。

接收微服务不能忽略或避免传入的消息。如果它这样做，发送者将直接从响应中得知。图 5.5 展示了视频流微服务如何将查看的消息直接发送到历史微服务，该服务提供直接且即时的响应。

在某些用例中，通常需要使用直接消息。它的主要缺点是它要求通信两端两个微服务紧密耦合。我们通常更愿意避免微服务之间的紧密耦合，因此我们将频繁使用间接消息而不是直接消息。

![图片](img/CH05_F05_Davis4.png)

图 5.5 通过名称显式发送直接消息到历史微服务，并立即处理。

### 5.6.2 间接消息

*间接* *消息* 在通信过程的两端之间引入了一个中介。我们在微服务之间添加了一个中间人。因此，通信的双方实际上不必相互了解。这种通信方式导致我们的微服务之间的耦合更加松散。这意味着两件事：

+   *消息通过中介发送，这样消息的发送者和接收者都不知道涉及了哪个其他微服务。* 对于发送者来说，甚至不知道是否有其他微服务会接收这条消息！

+   *因为接收者不知道哪个微服务发送了消息，所以它不能发送直接的回复。* 这意味着这种通信方式不能应用于需要直接响应以确认成功或失败的情况。

当发送微服务不在乎是否采取了后续操作时，我们应该使用间接消息。我们还可以用它向整个应用程序广播消息（例如，通知其他微服务可能感兴趣的重要事件）。

注意：我们使用间接消息来宣布不需要直接响应的重要事件。这种消息方式比直接消息提供了更灵活的通信结构，并且减少了我们的微服务之间的耦合。

图 5.6 展示了视频流微服务（在左侧）如何通过消息队列（中介）向历史微服务（在右侧）发送间接消息。请注意，视频流微服务和历史微服务之间没有直接连接。这就是为什么我们可以说它们是 *松散耦合* 的。

![](img/CH05_F06_Davis4.png)

图 5.6 一个间接消息不会明确发送给微服务；相反，消息被放置在队列中，可以在稍后处理。

间接消息可以帮助我们构建灵活的消息架构来解决许多复杂的通信问题。不幸的是，这种灵活性带来了更高的复杂性。随着你的应用程序的增长，你会发现更难精确地映射通信路径，因为这些路径不是直接的，因此也不那么明显。在了解了直接和间接消息的概述之后，我们可以一头扎进尝试每种通信方法。

## 5.7 使用 HTTP 进行直接消息传递

在上一章中，我们使用 HTTP 进行数据检索，从存储中检索了我们的流媒体视频。在本章中，我们使用 HTTP 达到不同的目的：从一个微服务向另一个微服务发送直接消息。

注意：使用 HTTP 请求发送的消息会有直接的响应。我们可以立即知道消息的处理是成功还是失败。

具体来说，在本节中，我们将使用 HTTP POST 请求直接从视频流微服务向历史微服务发送消息。图 5.7 展示了这一过程。

![](img/CH05_F07_Davis4.png)

图 5.7 HTTP POST 请求通过名称显式地针对另一个微服务。

### 5.7.1 为什么使用 HTTP？

超文本传输协议（HTTP）是万维网的语言和基础，在创建 *网络服务* 时是事实上的标准。它被每个人所理解，并且是我们可以依赖的东西。

HTTP 已经被广泛用于创建表示状态转移（REST）API，我们不需要太费脑筋去想为什么我们应该使用它。它是为此类事情而设计的，并且被我们愿意与之合作的每一种编程语言所支持。我们还可以轻松访问与之相关的海量学习资源，而且讽刺的是，这些信息很可能会通过互联网世界万维网底层的 HTTP 协议传递给我们。

### 5.7.2 直接针对特定微服务发送消息

在我们向微服务发送消息之前，我们需要一种方法来定位它。与 HTTP 伴随的是另一种互联网协议，称为 *域名系统*（DNS）。这为我们提供了一种简单且几乎自动的方法，可以通过微服务的名称将消息直接发送到微服务。

关于微服务通信的一个关键问题是，我们如何将消息定向到另一个微服务？对这个问题的最简单答案是无处不在的 DNS，它将主机名转换为 IP 地址。这在使用 Docker Compose（容器名称是主机名）时自动工作，并且不需要太多努力就可以在我们的生产 Kubernetes 集群中使其工作。

图 5.8 显示了我们可以向特定的主机名发送 HTTP POST 消息。在发送 HTTP 请求时，会自动进行 DNS 查找，并将我们的主机名转换为微服务的互联网协议（IP）地址。

![图片](img/CH05_F08_Davis4.png)

图 5.8 显示了 HTTP 请求是如何通过 DNS 查找将目标微服务的主机名转换为互联网协议（IP）地址的。

IP 地址是一串数字，代表我们微服务的唯一互联网位置。请注意，仅仅因为它是 IP 地址，并不意味着我们正在谈论公共互联网。在这种情况下，IP 地址实际上代表一个位于私有网络中的私有服务器，无论是在我们的开发工作站上运行 Docker 运行时，还是在我们的生产 Kubernetes 集群内部运行。这是我们需要在发送 HTTP 请求时指向接收者的消息的 IP 地址，并且当我们发起请求时，DNS 会自动且几乎神奇地在幕后工作。

正如我们所做的那样，使用 Docker 和 Docker Compose 进行开发意味着 DNS 会自动工作，我们可以依赖它。当我们部署到我们的生产 Kubernetes 集群时，我们将有一些额外的工作来使我们的微服务可以通过 DNS 访问，但我们将在这第七章中讨论这个问题。

### 5.7.3 使用 HTTP POST 发送消息

消息传递方程有两个方面：一个微服务发送消息，另一个接收消息。在本节中，我们将探讨如何使用 HTTP POST 请求发送消息。

在 4.4.2 节中，我们查看了一个从微服务转发到另一个微服务的 HTTP GET 请求。我们当时使用内置的 Node.js http 库来做这件事。我们将再次使用这个库从一个微服务向另一个微服务发送请求。

列表 5.6 是从示例 2 视频流微服务的更新后的 index.js 文件中摘取的，展示了如何发送 HTTP POST 消息。它实现了一个新的函数 `sendViewedMessage`，当用户开始观看视频时，该函数会将查看的消息发送到历史微服务。

列表 5.6 使用 HTTP POST 发送直接消息（摘自第五章/示例 2/video-streaming/index.js）

```
function sendViewedMessage(videoPath) {           ①
    const postOptions = {                         ②
        method: "POST",                           ③
        headers: {
            "Content-Type": "application/json",   ④
        },
    };
    const requestBody = {                         ⑤
        videoPath: videoPath 
    };
    const req = http.request(                     ⑥
        "http://history/viewed",                  ⑦
        postOptions
    );
    req.on("close", () => {
        ...                                       ⑧
    });
    req.on("error", (err) => {
        ...                                       ⑨
    });
    req.write(JSON.stringify(requestBody));       ⑩
    req.end();                                    ⑪
}
```

① 一个辅助函数，用于将查看的消息发送到历史微服务。

② 配置 HTTP 请求的选项。

③ 设置 HTTP 方法为 POST。

④ 设置 HTTP 请求主体的内容类型。

⑤ HTTP 请求的主体定义了消息负载；这是我们随消息发送的数据。

⑥ 将 HTTP 请求发送到历史微服务。

⑦ 设置 HTTP 请求的 URL，该 URL 识别历史微服务和查看消息。

⑧ 当请求完成时调用此函数。

⑨ 处理可能发生的任何错误。

⑩ 将主体写入请求。

⑪ 完成请求。

我们调用 `http.request` 函数来创建 HTTP POST 请求。我们使用 URL http://history/viewed 将请求定向到历史微服务。这个 URL 结合了主机名（在这种情况下是 `history`）和路由（在这种情况下是 `viewed`）。正是这种组合识别了目标微服务和发送给它的消息。

分别处理请求的成功和失败回调函数。正是在这里，我们可以检测到错误并采取后续的补救措施。否则，如果请求成功，我们可能希望调用后续操作。

### 5.7.4 使用 HTTP POST 接收消息

在等式的另一边，我们通过在接收微服务中创建 Express 路由处理程序来接收 HTTP POST 消息。列表 5.7 展示了历史微服务的 index.js 文件摘录，展示了这一点。

更新的 `setupHandlers` 函数为 `viewed` 路由添加了一个 HTTP POST 处理程序以接收传入的消息。在这个列表中，我们只是将接收到的消息存储在数据库中，以保留查看历史记录。

列表 5.7 使用 HTTP POST 接收直接消息（摘自第五章/示例 2/history/index.js）

```
function setupHandlers(app, db) {
    const videosCollection = db.collection("videos");
    app.post("/viewed", (req, res) => {             ①
        const videoPath = req.body.videoPath;       ②
        videosCollection
        ➥ .insertOne({ videoPath: videoPath })     ③
            .then(() => {
                console.log(`Added video ${videoPath} to history.`);
                res.sendStatus(200);
            })
            .catch(err => {
                console.error(`Error adding video ${videoPath} 
                ➥ to history.`);
                console.error(err && err.stack || err);
                res.sendStatus(500);
            });
    });
}
```

① 处理通过 HTTP POST 请求接收到的查看消息。

② 从 HTTP 请求的 JSON 主体中提取数据。

③ 在数据库中记录视图。

你是否注意到了在 HTTP POST 处理程序中我们是如何通过 `req.body` 访问请求体的？我们将请求体作为消息 *负载* 处理。由于我们使用了 Express 的 body-parser 中间件，`body` 变量被自动解析为 JSON 格式，安装方式如下：

```
npm install --save body-parser
```

如果你对如何将 body-parser 中间件添加到 Express 感兴趣，请查看代码文件 chapter-5/example-2/history/index.js。

### 5.7.5 测试更新后的应用程序

现在是时候测试我们最新的代码，亲自看看这种消息操作是如何进行的了。打开一个终端，切换到 example-2 目录，并按常规方式启动应用程序：

```
docker-compose up --build
```

如果你收到任何关于容器已创建的错误，可能是因为你留下了上一个示例在运行。在从每个示例继续之前，务必使用

```
docker-compose down
```

等待微服务上线，然后将浏览器指向 http://localhost:4001/video。测试视频将开始播放。

切换回终端以查看 Docker Compose 输出。你应该会看到确认视频流微服务发送了已查看消息的输出，随后是一些显示历史微服务接收了消息的文本。

到目前为止，我们可以直接检查以确保“查看”操作已存储在数据库中。你需要安装数据库查看器。如果你已经从第四章安装了 Robo 3T，你可以使用它。

将你的数据库查看器连接到数据库（在 localhost:4000 上连接，这是 Docker Compose 文件中配置的端口），然后查看历史数据库的视频集合，确认每次刷新浏览器时都会创建一个新的记录。检查数据库是测试代码最终结果的一种实用方法。

### 5.7.6 直接消息的顺序

直接消息的一个潜在好处是能够拥有一个控制器微服务，它可以协调多个其他微服务之间的复杂行为序列。因为直接消息有直接响应，这允许单个微服务协调或编排多个其他微服务的活动。

这种类型的消息被称为 *同步通信* 的原因是我们可以像图 5.9 所示的那样协调消息。在图中，微服务 A 正在协调其他微服务的活动。

![图 5.9](img/CH05_F09_Davis4.png)

图 5.9 直接消息允许一个控制器微服务（此处为微服务 A）在多个其他微服务之间编排复杂行为。

注意 直接消息可以用来以明确的方式或定义良好的顺序协调行为。

使用直接消息，很容易跟踪代码并理解消息的顺序。你很快就会看到追踪间接消息的顺序并不那么容易。

### 5.7.7 我们取得了什么成果？

在 5.7 节中，我们探讨了使用 HTTP POST 请求直接从微服务向微服务发送已查看消息。这被称为 *直接消息*，因为我们可以通过名称直接将这些消息发送到特定的微服务。我们还可以立即知道消息是否成功处理或失败。

最好将此类消息视为命令或行动呼吁，而不是通知。由于直接消息的同步性质，我们可以对多个协调消息进行排序。当我们想要一个控制器微服务来协调其他微服务的复杂行为时，这很有用。

尽管直接消息可能很有用，有时也是必要的，但它们也有一些主要的缺点。首先，我们一次只能针对一个其他微服务。因此，当我们希望一条消息被多个接收者接收时，直接消息并不容易工作。

此外，直接消息是微服务之间高度耦合的点。有时高度耦合是必要的，但我们更喜欢尽可能避免它。从控制器微服务集中编排多个微服务的能力可能看起来像是一个优势，而且确实可以使了解应用程序中正在发生的事情变得更容易。

但最大的问题是，这可能会为可能是一个庞大且复杂的操作创建一个单点故障。如果在编排过程中控制微服务崩溃了会发生什么？我们的应用程序现在可能处于不一致的状态，并且可能已经丢失了数据。直接消息引起的问题可以通过间接消息来解决，这就是我们现在转向 RabbitMQ 的原因。

## 5.8 使用 RabbitMQ 进行间接消息传递

现在我们已经掌握了使用 HTTP POST 请求进行直接消息的方法，是时候看看间接消息了，这可以帮助我们解耦我们的微服务。一方面，它可能会使我们的应用程序架构更难以理解。另一方面，它对安全性、可扩展性、可扩展性、可靠性和性能有许多积极的副作用。

注意：RabbitMQ 允许我们解耦消息发送者与消息接收者。发送者不知道是否还有其他微服务将处理一条消息。

图 5.10 展示了在添加 RabbitMQ 服务器后我们应用程序的结构。视频流微服务不再直接耦合到历史微服务。相反，它将查看的消息发布到消息队列。然后，历史微服务在其自己的时间从队列中拉取消息。

![图片](img/CH05_F10_Davis4.png)

图 5.10 使用 RabbitMQ 通过消息队列间接向其他微服务发送消息

### 5.8.1 为什么选择 RabbitMQ？

RabbitMQ 是一种广为人知且成熟的用于消息队列的软件。许多公司都在普遍使用它，而且它也是我用于间接消息的首选解决方案。RabbitMQ 稳定且成熟。它是在十年前开发的，并且除了其他协议外，它还实现了高级消息队列协议（AMQP），这是一种消息代理通信的开放标准。

注意：RabbitMQ 以微服务之间的间接通信而闻名，并允许实现复杂和灵活的消息架构。

RabbitMQ 为所有流行的编程语言都提供了库，所以无论你的技术栈如何，你都不会有任何问题使用它。我们正在使用 Node.js，所以我们将使用 npm 注册表上可用的 amqplib 库。RabbitMQ 是开源的，并且相对容易入门。你可以在以下链接找到服务器的代码：

[`github.com/rabbitmq/rabbitmq-server`](https://github.com/rabbitmq/rabbitmq-server)

### 5.8.2 间接针对微服务发送消息

使用间接消息，我们并不是直接针对任何特定的微服务，但我们仍然需要将我们的消息指向某个东西。而那个东西将是一个 RabbitMQ 服务器。在那个服务器中，要么是一个命名队列，要么是一个消息交换。队列和交换的组合为我们提供了在结构化我们的消息架构方面的很大灵活性。

注意：消息发送者使用 DNS 解析 RabbitMQ 服务器的 IP 地址。然后它与它通信，在特定的命名队列或交换上发布消息。接收者也使用 DNS 定位 RabbitMQ 服务器并与它通信，从队列中检索消息。在任何时候，发送者和接收者都没有直接通信。

要向队列或交换发布消息，我们必须首先将 RabbitMQ 服务器添加到我们的应用程序中。然后我们可以使用 AMQP 代码库（称为 amqplib）来发送和接收消息。

在底层，DNS 将 RabbitMQ 主机名解析为 IP 地址。现在，我们不再像通过 HTTP POST 请求发送消息时那样将消息直接指向特定的微服务，而是将这些消息指向通过 DNS 定位的 RabbitMQ 服务器上的特定队列或交换。

![](img/CH05_F11_Davis4.png)

图 5.11 通过将消息推入 RabbitMQ 队列来发送消息。

间接消息的传输分为两部分进行，所以我将使用两个图来解释它。我们首先考虑使用队列，然后我们再看看使用交换。图 5.11 显示了视频流微服务**pushing**其消息到**viewed**队列。然后在图 5.12 中，我们可以看到历史微服务**pulling**队列中的消息。

![](img/CH05_F12_Davis4.png)

图 5.12 通过从 RabbitMQ 队列中拉取消息来接收消息。

我在这里使用了**pushing**和**pulling**这两个动词，因为这是一种很好的方式来可视化这个交易。在之前的 HTTP POST 中，我们可以想象视频流微服务正在将其消息推送到历史微服务，而历史微服务在这方面没有选择。消息被强制推送到历史微服务，而不考虑它实际上是否有处理它的能力。

使用间接消息，历史微服务得到了更多的控制。现在，当它准备好这样做时，它会从队列中拉取消息。当它不堪重负，没有能力接受新消息时，它可以自由地忽略这些消息，让它们在队列中堆积，直到它能够处理它们。

### 5.8.3 创建 RabbitMQ 服务器

让我们在我们的应用程序中添加一个 RabbitMQ 服务器。信不信由你，RabbitMQ 是用 Erlang 语言编写的。曾经有一段时间设置它可能很困难，但现在不再是了！如今，这已经变得非常简单，多亏了我们已经学到的 Docker 和 Docker Compose 技能。

列表 5.8 是 example-3 Docker Compose 文件的摘录，展示了如何将 RabbitMQ 服务器添加到我们的应用程序中。这是从 Docker Hub 上的镜像实例化容器的另一个例子，就像我们在第四章为 MongoDB 数据库所做的那样。

列表 5.8 向 Docker Compose 文件中添加 RabbitMQ 服务器（摘自第五章的 example-3/docker-compose.yaml）

```
version: '3'
services:
  # ... other services defined here ...
  rabbit:                               ①
    image: rabbitmq:3.8.1-management    ②
    container_name: rabbit              ③
    ports:                              ④
      - "5672:5672"                     ④
      - "15672:15672"                   ④
    expose:                             ⑤
      - "5672"                          ⑤
      - "15672"                         ⑤
    restart: always                     ⑥
  # ... more services defined here ...
```

① 定义了托管我们的 RabbitMQ 服务器的容器

② 我们使用 RabbitMQ 镜像的管理版本。这为我们提供了 RabbitMQ 控制台。

③ 设置了容器的名称。这是我们用来连接到 RabbitMQ 服务器的名称。

④ 配置了从主机操作系统到容器的端口映射

⑤ 配置了哪些容器端口被暴露。这些是连接到服务器和查看控制台的标准 RabbitMQ 端口。

⑥ 如果 RabbitMQ 服务器出现故障，这将使其自动重启。

### 5.8.4 探索 RabbitMQ 控制台

你可能已经注意到了列表 5.8 中 RabbitMQ 端口的配置。5672 端口是我们很快将用于通过 amqplib 通过 RabbitMQ 发送和接收消息的端口号。我们将使用 15672 端口访问 RabbitMQ 管理控制台。

注意 RabbitMQ 的控制台是了解 RabbitMQ 的工作方式以及更好地理解在应用程序中传递的消息的绝佳方式。

我们从名为 rabbitmq:3.8.1-management 的镜像启动了 RabbitMQ 服务器，因为这个镜像自带内置的管理控制台。控制台在图 5.13 中展示，它作为探索我们应用程序中消息流的一种图形方式。现在让我们看看它。自己启动应用程序，以便你可以尝试一下！

打开一个终端并切换到 example-3 目录。以正常方式启动应用程序（如果其他方式不起作用，我将会确保你记住这个命令！）：

```
docker-compose up --build
```

![](img/CH05_F13_Davis4.png)

图 5.13 RabbitMQ 管理控制台

除了数据库和你的微服务的输出之外，你还应该看到来自你的 RabbitMQ 服务器的输出流。给它一些时间启动，然后用你的网络浏览器指向 http://localhost:15672/。你可以使用默认用户名 *guest* 和默认密码 *guest* 登录。

你现在应该能看到 RabbitMQ 控制台。但与图 5.13 不同，你目前还看不到任何队列或交换机。我是在创建了查看队列之后截图的。我们将在稍后触发队列的创建，然后你可以回到控制台看看它的样子。

RabbitMQ 仪表板是一个有用的调试工具。我相信，能够可视化正在发生的事情总是比仅仅假设我们知道正在发生的事情要好。仪表板是那些优秀的可视化工具之一，它使我们的应用程序实际上在做什么一目了然！

你可能会注意到我们不需要包含 RabbitMQ 仪表板。我们可以使用 rabbitmq:3.8.1 的镜像，这是一个不包含仪表板的镜像。如果你正在构建一个精简的生产应用程序或者你有特定的安全顾虑，这可能是你的首选。但通常，我更喜欢在生产环境中保留仪表板（当然是在私有网络之后），因为这些工具对我们理解生产环境中的情况非常有价值。

### 5.8.5 将我们的微服务连接到消息队列

在 RabbitMQ 服务器就绪后，我们现在可以更新我们的微服务以连接到它。如果你从头开始编写代码，你必须首先将 amqplib npm 包安装到每个需要连接到 RabbitMQ 的微服务中：

```
npm install --save amqplib
```

如果你直接在 Node.js 下运行 example-3 的代码，你必须首先安装所有依赖项：

```
npm install
```

下一个列表是历史微服务的 index.js 文件的摘录。它展示了我们如何连接到 RabbitMQ 服务器。

列表 5.9 连接到 RabbitMQ 服务器（摘自第五章/示例-3/history/index.js）

```
// ... other package imports here ...
const amqp = require("amqplib");              ①
const RABBIT = process.env.RABBIT;            ②
// ... code omitted here ...
function connectRabbit() {                    ③
    return amqp.connect(RABBIT)               ④
        .then(messagingConnection => {
            return messagingConnection
            ➥ .createChannel();              ⑤
        });
}

// ... code omitted here ...
function main() {
    return connectDb()                        ⑥
        .then(db => {
            return connectRabbit()            ⑦
                .then(messageChannel => {
                    return startHttpServer(db, 
                    ➥ messageChannel);       ⑧
                });
        });
}
main()
    .then(() => console.log("Microservice online."))
    .catch(err => {
        console.error("Microservice failed to start.");
        console.error(err && err.stack || err);
    });    
```

① 导入 amqplib 库。这是与 RabbitMQ 服务器通信的 API。

② 获取连接到 RabbitMQ 的 URI

③ 一个用于创建连接的辅助函数

④ 连接到 RabbitMQ 服务器

⑤ 创建 RabbitMQ 消息通道

⑥ 连接到数据库

⑦ 连接到 RabbitMQ 服务器

⑧ 启动 HTTP 服务器

列表 5.9 和列表 5.10（紧随其后）最重要的部分是如何通过 RABBIT 环境变量配置到 RabbitMQ 服务器的连接。列表 5.10 是 example-3 Docker Compose 文件的摘录。它设置了 RABBIT 环境变量，包括用户名（guest）、密码（也是 guest）、服务器的主机名（rabbit）和连接的端口号（5672）。

列表 5.10 配置历史微服务（摘自第五章/示例-3/docker-compose.yaml）

```
version: '3'
services:
  # ... other services defined here ...
  history:
    image: history
    build: 
      context: ./history
      dockerfile: Dockerfile-dev
    container_name: history
    volumes:
      - /tmp/history/npm-cache:/root/.npm:z
      - ./history/src:/usr/src/app/src:z
    ports:
     - "4002:80"
    environment:
      - PORT=80
      - RABBIT=amqp://guest:guest@rabbit:5672     ①
      - DBHOST=mongodb://db:27017
      - DBNAME=history
      - NODE_ENV=development
    depends_on:
      - db
      - rabbit                                    ②
    restart: "no"
```

① 设置连接到 RabbitMQ 的 URL

② 历史微服务现在依赖于我们在列表 5.8 中定义的 rabbit 容器。

这个谜题还有一个部分你可能直到尝试启动这个版本的应用程序时才意识到。RabbitMQ 服务器相当重量级，启动并准备好接受连接需要时间。另一方面，我们的微服务轻量级，只需片刻即可准备就绪。

当我们的微服务尝试连接到 RabbitMQ 但 RabbitMQ 尚未准备好时会发生什么？它会出错并终止！我们现在遇到了问题，因为我们应用程序中有启动依赖项需要按特定顺序解决。

要成为一个容错且表现良好的微服务，它实际上应该在尝试连接之前等待 RabbitMQ 服务器准备好。更好的是，如果 RabbitMQ 突然关闭（例如，因为我们正在升级它），我们希望我们的微服务能够处理断开连接并在尽可能快的时间内自动重新连接。我们希望它能这样工作，但这更复杂。目前，我们将使用一个简单的解决方案来解决这个问题。在第十章中，我们将学习一种更复杂的方式来处理这个问题。

解决这个问题的最简单方法是什么？我们将在 Dockerfile 中添加一个额外的命令，以延迟我们的微服务直到 RabbitMQ 服务器准备好。我们将使用通过 npm 安装的方便的`wait-port`命令：

```
npm install --save wait-port
```

列表 5.11 显示了带有`wait-port`命令的历史微服务更新后的 Dockerfile。我们使用这个命令来延迟微服务的启动，直到 RabbitMQ 启动后。

列表 5.11 历史微服务的更新后的 Dockerfile，它等待 RabbitMQ（第五章/示例 3/历史/Dockerfile-dev）

```
FROM node:10.15.2-alpine
WORKDIR /usr/src/app
COPY package*.json ./
CMD npm config set cache-min 9999999 && \ 
    npm install && \
    npx wait-port rabbit:5672 && \     ①
    npm run start:dev                  ②
```

① 使用 npx 调用本地安装的`wait-port`命令，等待在主机名为 rabbit 的服务器上端口 5672 接受连接

② 在`wait-port`完成后，启动历史微服务

同时，我们应该更新 Dockerfile 的生产版本。在我们工作时，保持两个版本同步是好事。

使用`wait-port`是在我们首次开始构建微服务应用程序时快速启动的一种简单而有效的方法。然而，它并不非常健壮。启动顺序问题并不是唯一的问题。我们通常希望我们的微服务具有容错能力，能够应对其他服务器和微服务的不可避免的中断。我们将在第十章中回到这个问题。

在这一点上，你可能想知道为什么在第四章开始使用 MongoDB 数据库时我们没有遇到这个启动顺序问题？当然，数据库也需要时间来启动，但我们不需要在连接到它之前等待它准备好。

好吧，这完全是 MongoDB 库中良好的软件工程的结果。它已经为自动重新连接进行了编程，所以感谢 MongoDB 工程师为你付出了这么多的努力。这应该让你有所思考。当编写代码库时，花点时间考虑我们的用户视角，将转化为他们更好的体验。

### 5.8.6 单接收者间接消息

我们可以通过多种方式配置 RabbitMQ 中的消息路由来实现各种消息架构。我们将专注于两种简单的配置，这些配置将处理你在构建应用程序时面临的大多数通信问题。

第一个是单接收者消息的设置，我们将使用它来创建一对一，但仍然间接的消息通道，在微服务之间。尽管在这个配置中，您允许有多个发送者和接收者参与，但您可以保证每个单独的消息只由一个微服务接收。这对于将工作分配给一组微服务时非常出色，但这项工作应由第一个能够处理它的微服务来处理。

注意 单接收者消息是 **一对一** 的：一条消息从一个微服务发送，只被另一个微服务接收。这是一种确保在您的应用程序中特定工作只执行一次的绝佳方式。

接收单接收者消息

让我们在历史微服务中添加代码，以便它可以接收单接收者消息。我们已经在 5.8.5 节中添加了连接到我们的 RabbitMQ 服务器的代码。一旦连接，我们现在可以 *断言* 一个消息队列并开始从该队列拉取消息。注意我在这里使用的新术语。

我说的是“断言”一个消息队列，而不是“创建”一个消息队列。区别在于多个微服务可以断言一个队列，所以它就像检查队列是否存在，然后只有在它不存在时才创建它。这意味着队列只创建一次，并在所有参与的微服务之间共享。不要将这与其他在编程中常用的一种断言概念混淆——这两个是两个不同的概念。

列表 5.12 是历史微服务的 index.js 的摘录，它断言了已查看队列并调用 `consume` 以开始接收消息。这就是它！实际上，接收 RabbitMQ 消息所需的代码并不多。

列表 5.12 从 RabbitMQ 队列中消费已查看消息（摘自 chapter-5/example-3/history/index.js）

```
// ... code omitted here ...
function setupHandlers(app, db, messageChannel) {
    const videosCollection = db.collection("videos");
    function consumeViewedMessage(msg) {                                     ①
        const parsedMsg = JSON
        ➥ .parse(msg.content.toString());                                   ②

        return videosCollection.insertOne({ videoPath: parsedMsg.videoPath })③
            .then(() => {                                                    ④
                messageChannel.ack(msg);                                     ⑤
            });
    };
    return messageChannel.assertQueue("viewed", {})                          ⑥
        .then(() => {
            return messageChannel.consume("viewed", 
            ➥ consumeViewedMessage);                                        ⑦
        });
}
// ... code omitted here ...
```

① 一个处理传入消息的函数

② 将 JSON 消息解析为 JavaScript 对象

③ 在历史数据库中记录查看

④ 如果没有错误……

⑤ ……确认消息。

⑥ 断言我们有一个已查看队列

⑦ 开始从已查看队列接收消息

列表 5.12 中的代码仅因我们希望以 JSON 格式发送消息而略显复杂，但 RabbitMQ 并没有原生支持 JSON。因此，我们必须手动解析传入的消息有效负载。

RabbitMQ 实际上对消息有效负载的格式是中立的，从它的角度来看，一条消息只是一个二进制数据块。这在性能关键的情况下可能很有用，我们可能会用更有效的二进制格式来替换 JSON。

发送单接收者消息

使用 RabbitMQ 发送简单消息甚至比接收消息更容易。列表 5.13 是视频流微服务的 index.js 文件的摘录。假设我们已经添加了类似列表 5.9 中的代码并将此微服务连接到 RabbitMQ 服务器。我们现在通过指定队列名称（viewed）和提供消息负载来调用 `publish`。

列表 5.13 将观看消息发布到 RabbitMQ 队列（摘自第五章/示例 3/video-streaming/index.js）

```
// ... code omitted here ...
function sendViewedMessage(messageChannel, 
➥ videoPath) {                              ①
    const msg = { videoPath: videoPath };    ②
    const jsonMsg = JSON.stringify(msg);     ③
    messageChannel.publish("", "viewed", 
    ➥ Buffer.from(jsonMsg));                ④
}
// ... code omitted here ...
```

① 发送观看消息的辅助函数

② 定义消息负载。这是我们随消息发送的数据。

③ 将消息转换为 JSON 格式

④ 将消息发布到观看队列

再次强调，列表 5.13 只稍微复杂一些，因为我们必须在发送消息之前手动 **字符串化**（或序列化）我们的消息负载为 JSON。除此之外，它相当直接。现在我们有了视频流微服务，每当用户观看视频时，就会发布观看消息。

测试单收件人消息

我们已经准备好进行另一次测试运行。我们有一个 RabbitMQ 服务器。视频流微服务正在发送观看消息，而历史微服务正在接收它。如果您还没有这样做，请启动示例-3 应用程序：

```
docker-compose up --build
```

等待数据库和 RabbitMQ 启动以及微服务建立连接。现在将您的网络浏览器指向 http://localhost:4001/video。检查输出以确认消息已发送并接收。您可以使用 Robo3T 检查历史微服务是否在其数据库中为观看创建了新的记录。

### 5.8.7 多收件人消息

发送单收件人消息是 RabbitMQ 的第一个常见用例。它也是最简单的，这就是为什么我们从它开始。潜在地更有用得多的是多收件人（或广播式）消息。简单来说，一个微服务发送消息，但许多其他微服务可以接收它。

我们使用这种类型的消息用于 **通知**（例如，指示应用程序中发生重要事件的邮件，如视频被观看的事件）。这是多个其他微服务都希望了解的消息。

注意 多收件人消息是 **一点对多**：消息只从一个微服务发送，但可能被许多其他微服务接收。这是在您的应用程序中发布通知的绝佳方式。

要使这适用于 RabbitMQ，我们现在必须使用一个消息交换。图 5.14 显示了视频流微服务将其消息发布到观看交换。从交换中，消息被路由到多个匿名队列，以便多个微服务同时处理。

当你查看图 5.14 时，你可能会想知道推荐微服务是从哪里来的？不，你没有错过任何东西！我实际上在你没注意的时候悄悄地引入了一个新的微服务。我不得不这样做；否则，我没有办法向你展示这些广播式消息是如何工作的。

![图片](img/CH05_F14_Davis4.png)

图 5.14 向多个收件人广播要处理的消息

推荐微服务将在以后向我们的用户推荐观看的视频。它现在出现在这里只是为了让我们看到多收件人消息的实际操作。

接收多收件人消息

接收多收件人消息与接收单收件人消息没有太大区别。以下是从历史微服务的 index.js 文件中摘取的代码。

列表 5.14 从 RabbitMQ 交换机中消费已查看的消息（摘自第五章/示例 4/history/index.js）

```
// ... code omitted here ...
function setupHandlers(app, db, messageChannel) {
    const videosCollection = db.collection("videos");
    function consumeViewedMessage(msg) {                          ①
        const parsedMsg = JSON.parse(msg
        ➥ .content.toString());                                  ②

        return videosCollection.insertOne({ videoPath: parsedMsg
                               ➥ .videoPath })                   ③
            .then(() => {                                         ④
                messageChannel.ack(msg);                          ⑤
            });
    };
    return messageChannel
    ➥ .assertExchange("viewed", "fanout")                        ⑥
        .then(() => {
            return messageChannel
            ➥ .assertQueue("", { exclusive: true });             ⑦
        })
        .then(response => {
            const queueName = response.queue;                     ⑧
            return messageChannel
            ➥ .bindQueue(queueName, "viewed", "")                ⑨
                .then(() => {
                    return messageChannel
                        ➥ .consume(queueName, consumeViewedMessage); ⑩
                });
        });
}
// ... code omitted here ...
```

① 一个处理传入消息的函数

② 将 JSON 消息解析为 JavaScript 对象

③ 记录历史数据库中的视图

④ 如果没有错误……

⑤ ... 确认消息。

⑥ 断言我们有一个已查看的交换机

⑦ 创建一个匿名队列。选项 exclusive 设置为 true，这样当微服务从队列断开连接时，队列将被自动释放（否则，我们的应用程序将出现内存泄漏）。

⑧ 为匿名队列分配一个自动生成的唯一标识符作为其名称

⑨ 将队列绑定到交换机

⑩ 开始从绑定到已查看交换机的匿名队列接收消息

列表 5.14 与列表 5.12 的区别在于我们现在*断言*的是已查看的交换机（又是那个断言术语），而不是已查看的队列。之后，我们断言一个匿名队列。通过创建一个无名的队列，我们得到一个只为这个微服务创建的独特队列。已查看的交换机在所有微服务之间共享，但匿名队列仅由这个微服务拥有。这个细节是这个工作的重要部分。

在创建无命名的队列时，我们将得到 RabbitMQ 生成的随机名称。RabbitMQ 分配给我们的队列的名称只重要，因为我们现在必须将队列绑定到已查看交换机。这种绑定将交换机和队列连接起来，使得 RabbitMQ 在交换机上发布的消息被路由到队列。

每个其他想要接收已查看消息的微服务（例如，我悄悄引入的推荐微服务）都会创建自己的无命名的队列来绑定到已查看交换机。我们可以有任意数量的其他微服务绑定到已查看交换机，并且当消息发布到交换机时，这些微服务都会在自己的匿名队列上接收到消息的副本。

发送多收件人消息

再次强调，发送多收件人消息与发送单收件人消息类似。列表 5.15 是视频流微服务的 index.js 文件的摘录。我在这个摘录中包含了更多代码，因为了解在这种情况下与 RabbitMQ 服务的连接方式很重要。它之所以不同，是因为微服务启动时我们断言存在查看交换。

在启动时执行此操作意味着我们可以依赖交换在整个微服务生命周期中的存在。在列表中，我们仍然使用 `publish` 函数发送消息，但现在我们指定消息是发布到查看交换而不是查看队列。

列表 5.15 将查看消息发布到 RabbitMQ 交换（来自第四章示例 3/video-streaming/index.js 的摘录）

```
// ... code omitted here ...
function connectRabbit() {
    return amqp.connect(RABBIT)
        .then(connection => {
            console.log("Connected to RabbitMQ.");
            return connection.createChannel()
                .then(messageChannel => {
                    return messageChannel.assertExchange(
                    ➥ "viewed", "fanout")                    ①
                        .then(() => {
                            return messageChannel;
                        });
                });
        });
}
function sendViewedMessage(
➥ messageChannel, videoPath) {                               ②
    const msg = { videoPath: videoPath };                     ③
    const jsonMsg = JSON.stringify(msg);                      ④
    messageChannel
    ➥ .publish("viewed", "", Buffer.from(jsonMsg));          ⑤
}
// ... code omitted here ...
function main() {
    return connectRabbit()                                    ⑥
        .then(messageChannel => {
            return startHttpServer(messageChannel);           ⑦
        });
}
// ... code omitted here ...
```

① 断言我们有一个查看交换

② 一个发送查看消息的辅助函数

③ 定义消息的有效负载

④ 将消息转换为 JSON 格式

⑤ 将消息发布到查看交换

⑥ 连接到 RabbitMQ 服务器

⑦ 启动 HTTP 服务器

测试多收件人消息

让我们测试我们的更新代码。正是为了这个测试，我将推荐微服务添加到我们的应用程序中。这个新微服务实际上只是一个存根；它除了打印接收到的消息外，什么都不做。这足以表明多个微服务可以处理这些消息。打开终端，切换到 example-4 目录，并执行常规操作：

```
docker-compose up --build
```

当你在网页浏览器中访问 http://localhost:4001/video 时，你应该会看到消息被打印到控制台，以显示历史微服务和推荐微服务都在接收查看的消息。

这之所以可行，是因为我们有一个绑定到两个队列的交换：我们为每个接收微服务有一个队列。仅使用单个队列无法实现这种行为。当我们向单个共享队列发布消息时，接收微服务会竞争成为第一个拉取并处理该消息的服务。你可以把这看作是一种负载均衡。这有时是一种有用的技术，但广播式消息通常更有用。

### 5.8.8 间接消息的排序

间接消息有许多积极的好处，但这些都可能使理解和控制我们应用程序的行为变得更加困难。对于间接消息，没有直接响应的方式，并且从发送者的角度来看，接收者可能根本不存在！发送者无法知道是否有一个接收者在等待接收其消息。

注意：由于间接消息没有“中央控制”，因此这些允许实现更加灵活、可扩展和可演化的消息架构。每个独立的微服务负责如何响应传入的消息，并且可以生成许多其他响应消息。

与直接消息不同，间接消息没有单个微服务负责协调其他微服务。这并不一定是个坏事情。考虑一下，有一个单一的控制器微服务意味着我们有一个单点故障，这无疑是件坏事。如果控制微服务在复杂协调过程中崩溃，会发生什么？正在进行的任何操作都将丢失！这就是直接消息可能产生的可怕副作用。

有时直接消息很有用，但一般来说，间接消息允许构建更复杂和更具弹性的行为网络。我们可能难以理解它在复杂性中的整体结构，但至少我们知道它是可靠的！这是因为没有单个点可以失败，微服务之间的连接是通过可靠和容错的队列（好吧，RabbitMQ 可能会失败，但它比我们自己的微服务失败的可能性要小得多）实现的。

任何特定的微服务都可能失败，但即使它在处理消息时失败，我们也知道消息不会丢失。因为当微服务崩溃时，消息不会被确认，所以这些消息最终会被发送到另一个微服务进行处理。正是这些小技术的总和，帮助我们构建了一个坚固可靠且可靠的微服务应用程序。请查看图 5.15，以更直观地了解间接消息如何在您的应用程序中按顺序排列成动态的消息流。

![图 5.15](img/CH05_F15_Davis4.png)

图 5.15 间接消息允许更自由和灵活地编排微服务，从而产生涌现行为。

### 5.8.9 我们取得了什么成果？

在本节中，我们学习了如何使用 RabbitMQ 在我们的微服务之间发送间接消息。首先，我们尝试发送单收件人消息。然后，我们改为多收件人消息，以便我们可以广播全应用的消息。

注意：使用间接的多收件人消息似乎是处理查看消息的正确方式，因此我们的微服务耦合度更低。这是一个很好的成果。

我们本可以提前规划并直接转向间接广播风格的短信，但这是经验的好处。现在我们已经考虑了所有选项，您有了这样的经验，并且更有能力根据您向应用程序添加更多消息的情况，自行决定需要哪种风格的消息。

## 5.9 微服务通信回顾

现在，您手头上有两种不同的消息风格可供使用，以使您的微服务相互通信。您已经学会了如何使用 HTTP 请求发送直接消息，以及如何使用 RabbitMQ 发送间接消息。使用 RabbitMQ，您可以发送单收件人和多收件人（或广播）消息。

我们有一个灵活的消息结构，未来可以扩展。稍后，我们将向这个应用添加更多微服务，每个微服务可能或可能不会关心查看的消息。但那些关心的可以简单地处理它，而无需我们修改消息的原始发送者。

我们讨论了为什么你可能想要选择一种消息风格而不是另一种风格的各种原因。为了您的方便，这些信息已在表 5.2 中总结。当您在特定情况下决定需要哪种消息风格时，可以参考此表。

表 5.2 何时使用每种通信类型

| 情况 | 使用什么 |
| --- | --- |
| 我需要通过名称将消息直接发送到特定的微服务。 | 直接消息：HTTP |
| 我需要确认消息处理成功或失败。 | 直接消息：HTTP |
| 我需要在第一个消息完成后对后续消息进行排序。 | 直接消息：HTTP |
| 我希望一个微服务能够协调其他微服务的活动。 | 直接消息：HTTP |
| 我需要将一条消息广播到整个应用中，以通知零个或多个微服务系统中的事件（我不关心消息是否被处理）。 | 间接消息：RabbitMQ |
| 我想要解耦发送者和接收者（这样它们可以更容易地独立更改和演进）。 | 间接消息：RabbitMQ |
| 我希望发送者和接收者的性能是独立的（发送者可以发送任意数量的消息，接收者将按自己的时间处理这些消息）。 | 间接消息：RabbitMQ |
| 我要确保如果消息处理失败，它将自动稍后重试，直到成功（这样就不会因为间歇性故障而丢失消息）。 | 间接消息：RabbitMQ |
| 我需要将消息的处理负载均衡到一组工人中的一个。 | 要么 HTTP 要么 RabbitMQ |
| 我需要将消息的处理分配给多个可以并行操作的工人。 | 间接消息：RabbitMQ |

## 5.10 继续你的学习

本章带您游览了我们可以让我们的微服务进行通信的各种方式。我们使用了 HTTP 进行直接消息，RabbitMQ 进行间接消息。像往常一样，我们只是简要地触及了这些主题，还有很多可以学习。以下是一些学习更多知识的优秀资源：

+   *《API 设计模式》* 由 JJ Geewax 著（Manning，预计 2021 年春季）

+   *《Web API 设计》* 由 Arnaud Lauret 著（Manning，2019 年）

+   *《深入 RabbitMQ》* 由 Gavin M Roy 著（Manning，2017 年）

+   《RabbitMQ in Action》由 Alvaro Videla 和 Jason J.W. Williams 著（Manning，2012 年）

要了解更多关于 amqplib 包的信息，请在此处阅读文档：

+   [`www.squaremobius.net/amqp.node/`](http://www.squaremobius.net/amqp.node/)

要了解更多关于 `wait-port` 命令的信息，请参阅：

+   [`github.com/dwmkerr/wait-port`](https://github.com/dwmkerr/wait-port)

我们已经走了很长的路。在构建我们的第一个微服务后，我们迅速扩展到开发多个通信微服务。每个微服务都可以有自己的数据库和/或文件存储。我们现在使用实时重新加载来高效地在我们编码时重新加载整个应用程序。

接下来是什么？我们有一个初出茅庐的应用程序。它目前还做不了很多事情，但这并不是避免将其部署到生产环境的原因。将我们的应用程序部署到生产环境可能是一项艰巨的任务，最好在应用程序小而简单时完成。因此，无需多言，在第六章和第七章中，我们将把我们的应用程序部署到生产环境！

## 摘要

+   我们可以使用 Docker 卷在开发工作站和应用程序中的容器之间共享代码。

+   使用 nodemon 进行实时重新加载意味着我们可以更新我们的代码，并且应用程序中相关的微服务可以自动重新加载，而无需重新构建和重启整个应用程序。

+   微服务之间的通信有两种风格：直接和间接。

+   当我们想要明确地序列化消息流或仔细编排其他微服务的行为时，直接或同步消息最为有用。

+   使用直接消息，我们可以立即知道消息处理是否成功或失败。

+   间接或异步消息帮助我们解耦微服务，这有助于促进灵活和可扩展的应用程序的开发。

+   使用间接消息，我们可以在整个应用程序中广播一条消息，以通知其他微服务系统中的重要事件。

+   HTTP POST 请求用于在微服务之间发送直接消息。

+   RabbitMQ 是一种用于消息队列的软件。我们可以用它来在微服务之间发送间接消息。

+   尽管我们使用了 wait-port npm 包在微服务连接到它之前等待 RabbitMQ 服务器准备好，但在第十章中，我们将学习一种更好的等待当前不可用的其他服务的方法。

+   决定使用 HTTP 还是 RabbitMQ 取决于具体情况的需求。请参考第 5.9 节中的表 5.2，以帮助您根据需求决定使用哪种方式。
