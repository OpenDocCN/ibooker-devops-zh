# 第十一章：案例研究：设计、实现和维护公信 CA

> 原文：[11. Case Study: Designing, Implementing, and Maintaining a Publicly Trusted CA](https://google.github.io/building-secure-and-reliable-systems/raw/ch11.html)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)


作者：Andy Warner、James Kasten、Rob Smits、Piotr Kucharski 和 Sergey Simakov

# 公信证书颁发机构的背景

公信证书颁发机构通过为传输层安全性（TLS）、S/MIME 等常见的分布式信任场景颁发证书，充当互联网传输层的信任锚点。它们是浏览器、操作系统和设备默认信任的 CA 集合。因此，编写和维护一个公信 CA 引发了许多安全性和可靠性考虑。

要成为公信并保持这一地位，CA 必须通过跨不同平台和用例的一系列标准。至少，公信 CA 必须接受诸如[WebTrust](https://oreil.ly/ubToZ)和[欧洲电信标准化协会（ETSI）](https://www.etsi.org)等组织设定的标准的审计。公信 CA 还必须满足[CA/Browser 论坛基线要求](https://oreil.ly/gfdBF)的目标。这些评估评估逻辑和物理安全控制、程序和实践，一个典型的公信 CA 每年至少花费四分之一的时间进行这些审计。此外，大多数浏览器和操作系统都有自己独特的要求，CA 必须在被默认信任之前满足这些要求。随着要求的变化，CA 需要适应并愿意进行流程或基础设施的变更。

你的组织很可能永远不需要构建一个公信 CA——大多数组织依赖第三方获取公共 TLS 证书、代码签名证书和其他需要用户广泛信任的证书。考虑到这一点，本案例研究的目标不是向您展示如何构建一个公信 CA，而是强调我们的一些发现可能与您环境中的项目产生共鸣。主要的收获包括以下内容：

+   我们选择的编程语言以及在处理第三方生成的数据时使用分段或容器使整体环境更加安全。

+   严格测试和加固代码——无论是我们自己生成的代码还是第三方代码——对于解决基本的可靠性和安全性问题至关重要。

+   当我们在设计中减少复杂性并用自动化替换手动步骤时，我们的基础设施变得更安全、更可靠。

+   了解我们的威胁模型使我们能够构建验证和恢复机制，使我们能够更好地提前为灾难做准备。

# 我们为什么需要一个公信 CA？

随着时间的推移，我们对公信 CA 的业务需求发生了变化。在谷歌早期，我们从第三方 CA 购买了所有的公共证书。这种方法存在三个固有问题，我们希望解决：

依赖第三方

业务需求需要高度的信任——例如，向客户提供云服务——这意味着我们需要对证书的发放和处理进行强有力的验证和控制。即使我们在 CA 生态系统中进行了强制性的审计，我们仍然不确定第三方是否能够达到高标准的安全性。公信 CA 中的显著安全漏洞巩固了我们对安全性的看法。

自动化的需求

谷歌拥有成千上万的公司拥有的域名，为全球用户提供服务。作为我们普遍的 TLS 工作的一部分（参见[“示例：增加 HTTPS 使用率”](ch07.html#example_increasing_https_usage)），我们希望保护我们拥有的每个域，并经常更换证书。我们还希望为客户提供获取 TLS 证书的简便方法。自动获取新证书很困难，因为第三方公信 CA 通常没有可扩展的 API，或者提供的 SLA 低于我们的需求。因此，这些证书的请求过程很大程度上涉及容易出错的手动方法。

成本

考虑到谷歌想要为自己的网络属性和客户代表使用数百万个 TLS 证书，成本分析显示，与继续从第三方根 CA 获取证书相比，设计、实现和维护我们自己的 CA 将更具成本效益。

# 建设或购买决策

一旦谷歌决定要运营一个公信 CA，我们就必须决定是购买商业软件来运营 CA，还是编写我们自己的软件。最终，我们决定自己开发 CA 的核心部分，并在必要时集成开源和商业解决方案。在许多决定因素中，这个决定背后有一些主要的动机：

透明度和验证

CA 的商业解决方案通常没有我们对代码或供应链的审计能力，这是我们对于如此关键的基础设施所需的。尽管它与开源库集成并使用了一些第三方专有代码，但编写和测试我们自己的 CA 软件使我们对正在构建的系统更加有信心。

集成能力

我们希望通过与谷歌的安全关键基础设施集成，简化 CA 的实现和维护。例如，我们可以在[Spanner](https://oreil.ly/ZnhV-)中的配置文件中设置定期备份。

灵活性

更广泛的互联网社区正在开发新的倡议，以提高生态系统的安全性。[证书透明度](https://www.certificate-transparency.org)——一种监视和审计证书的方式——以及使用 DNS、HTTP 和其他方法进行域验证⁵是两个典型的例子。我们希望成为这类倡议的早期采用者，自定义 CA 是我们能够迅速增加这种灵活性的最佳选择。

# 设计、实现和维护考虑

为了保护我们的 CA，我们创建了一个三层分层架构，其中每一层负责发行过程的不同部分：证书请求解析、注册机构功能（路由和逻辑）和证书签发。每一层都由具有明确定义责任的微服务组成。我们还设计了一个双信任区域架构，其中不受信任的输入在不同的环境中处理关键操作。这种分割创建了精心定义的边界，促进了可理解性和审查的便利。该架构还使得发动攻击更加困难：由于组件的功能受到限制，攻击者如果获得对特定组件的访问权限，也将受到功能受限的限制。要获得额外的访问权限，攻击者必须绕过额外的审计点。

每个微服务都是以简单性作为关键原则进行设计和实现的。在 CA 的整个生命周期中，我们不断地以简单性为考量对每个组件进行重构。我们对代码（包括内部开发和第三方）和数据进行严格的测试和验证。当需要提高安全性时，我们还会对代码进行容器化。本节详细描述了我们通过良好的设计和实现选择来解决安全性和可靠性的方法。

## 编程语言选择

对于接受任意不受信任输入的系统部分的编程语言选择是设计的一个重要方面。最终，我们决定用 Go 和 C++的混合编写 CA，并根据其目的选择使用哪种语言来处理每个子组件。Go 和 C++都可以与经过充分测试的加密库进行互操作，表现出优异的性能，并拥有强大的生态系统框架和工具来实现常见任务。

由于 Go 是内存安全的，它在处理 CA 处理任意输入时具有一些额外的安全优势。例如，[证书签名请求（CSR）](https://oreil.ly/8YkPI)代表 CA 的不受信任输入。CSR 可能来自我们内部系统中的一个，这可能相对安全，也可能来自互联网用户（甚至是恶意行为者）。代码中解析 DER（用于证书的编码格式）的代码存在与内存相关的漏洞的悠久历史，因此我们希望使用一种提供额外安全性的内存安全语言。[Go](https://oreil.ly/WM_zw)符合要求。

C++不是内存安全的，但对于系统的关键子组件具有良好的互操作性，特别是对于谷歌核心基础设施的某些组件。为了保护这些代码，我们在安全区域中运行它，并在数据到达该区域之前验证所有数据。例如，对于 CSR 处理，我们在 Go 中解析请求，然后将其传递给 C++子系统进行相同的操作，然后比较结果。如果存在差异，则不进行处理。

此外，我们在所有 C++代码的提交前[强制执行良好的安全实践和可读性](https://oreil.ly/m8dug)，谷歌的集中式工具链实现了各种编译时和运行时缓解措施。这些包括以下内容：

[W^X](https://oreil.ly/9gNIa)

通过复制 shellcode 并跳转到该内存来破坏`mmap`和`PROT_EXEC`的常见利用技巧。这种缓解措施不会造成 CPU 或内存性能损失。

[Scudo Allocator](https://oreil.ly/xpo5t)

用户模式安全堆分配器。

[SafeStack](https://oreil.ly/EPwod)

一种安全缓解技术，可防范基于堆栈缓冲区溢出的攻击。

## 复杂性与可理解性

作为一种防御措施，我们明确选择实现 CA 的功能有限，与标准中提供的完整选项相比（参见[“设计可理解的系统”](ch06.html#designing_understandable_systems)）。我们的主要用例是为具有常用属性和扩展的标准 Web 服务颁发证书。我们对商业和开源 CA 软件选项的评估显示，它们试图适应我们不需要的奇特属性和扩展导致了系统的复杂性，使软件难以验证且更容易出错。因此，我们选择编写具有有限功能和更好可理解性的 CA，以便更容易审计预期的输入和输出。

我们不断努力简化 CA 的架构，使其更易于理解和维护。有一次，我们意识到我们的架构创建了太多不同的微服务，导致维护成本增加。虽然我们希望获得模块化服务和明确定义的边界的好处，但我们发现将系统的某些部分合并更简单。在另一种情况下，我们意识到我们对 RPC 调用的 ACL 检查是在每个实例中手动实现的，这为开发人员和审阅人员出现错误提供了机会。我们重构了代码库，以集中 ACL 检查并消除添加新的 RPC 而不使用 ACL 的可能性。

## 保护第三方和开源组件

我们的自定义 CA 依赖于第三方代码，即开源库和商业模块。我们需要验证、加固和容器化这些代码。作为第一步，我们专注于 CA 使用的几个众所周知且广泛使用的开源软件包。即使是在安全环境中广泛使用的开源软件包，也可能来自具有强大安全背景的个人或组织，也容易受到漏洞的影响。我们对每个软件包进行了深入的安全审查，并提交了修补程序以解决我们发现的问题。在可能的情况下，我们还将所有第三方和开源组件都提交到下一节详细介绍的测试制度中。

我们使用两个安全区域——一个用于处理不受信任的数据，另一个用于处理敏感操作——也为我们提供了一些分层保护，以防止错误或恶意插入到代码中。前面提到的 CSR 解析器依赖于开源 X.509 库，并作为 Borg 容器中不受信任区域的微服务运行。这为这段代码提供了额外的保护层。

我们还必须保护专有的第三方闭源代码。运行一个公开可信的 CA 需要使用硬件安全模块（HSM）——由商业供应商提供的专用加密处理器——作为保护 CA 密钥的保险库。我们希望为与 HSM 交互的供应商提供的代码提供额外的验证层。与许多供应商提供的解决方案一样，我们可以进行的测试种类有限。为了保护系统免受内存泄漏等问题的影响，我们采取了以下步骤：

+   我们构建了必须与 HSM 库进行交互的 CA 的部分，采取了防御性措施，因为我们知道输入或输出可能存在风险。

+   我们在[*nsjail*](https://oreil.ly/QaE4s)中运行第三方代码，这是一个轻量级的进程隔离机制。

+   我们向供应商报告了我们发现的问题。

## 测试

为了保持项目的卫生，我们编写单元测试和集成测试（见第十三章）来覆盖各种场景。团队成员应在开发过程中编写这些测试，而同行评审则确保遵守这一做法。除了测试预期行为外，我们还测试负面情况。每隔几分钟，我们生成符合良好标准的测试证书签发条件，以及包含严重错误的条件。例如，我们明确测试了当未经授权的人员进行签发时，准确的错误消息是否会触发警报。拥有正面和负面测试条件的存储库使我们能够非常快速地对所有新的 CA 软件部署进行高可信度的端到端测试。

通过使用谷歌的集中式软件开发工具链，我们还获得了在提交前和构建后的集成自动代码测试的好处。正如在[“将静态分析集成到开发人员工作流程中”](ch13.html#integration_of_static_analysis_in_the_d)中讨论的那样，谷歌所有的代码更改都经过 Tricorder，我们的静态分析平台的检查。我们还对 CA 的代码进行各种消毒剂的检查，如 AddressSanitizer（ASAN）和 ThreadSanitizer，以识别常见错误（见[“动态程序分析”](ch13.html#dynamic_program_analysis)）。此外，我们对 CA 代码进行有针对性的模糊测试（见[“模糊测试”](ch13.html#fuzz_testing)）。

## CA 密钥材料的弹性

CA 面临的最严重风险是 CA 密钥材料的盗窃或滥用。公开可信的 CA 的大多数强制性安全控制措施都是针对可能导致这种滥用的常见问题，包括使用 HSM 和严格的访问控制等标准建议。

我们将 CA 的根密钥材料离线保存，并用多层物理保护来保护它，每个访问层都需要两方授权。对于日常证书签发，我们使用在线可用的中间密钥，这是行业标准做法。由于让公众信任的 CA 被广泛纳入生态系统（即浏览器、电视和手机）的过程可能需要多年时间，因此在遭受损害后旋转密钥（参见“旋转签名密钥”）作为恢复工作的一部分并不是一个简单或及时的过程。因此，密钥材料的丢失或被盗可能会造成重大中断。为了防范这种情况，我们在生态系统中成熟了其他根密钥材料（通过将材料分发给使用加密连接的浏览器和其他客户端），这样我们就可以在必要时替换备用材料。

## 数据验证

除了密钥材料的丢失，签发错误是 CA 可能犯的最严重的错误。我们努力设计我们的系统，以确保人为判断不能影响验证或签发，这意味着我们可以将注意力集中在 CA 代码和基础设施的正确性和健壮性上。

持续验证（见“持续验证”）确保系统的行为符合预期。为了在 Google 的公众信任 CA 中实现这一概念，我们自动在签发过程的多个阶段通过 linter 运行证书。linter 检查错误模式，例如确保证书具有有效的生命周期或者`subject:commonName`具有有效的长度。一旦证书经过验证，我们将其输入到证书透明日志中，这允许公众进行持续验证。为了防范恶意签发，我们还使用多个独立的日志系统，通过逐个比较两个系统的条目来确保一致性。这些日志在到达日志存储库之前会被签名，以提供进一步的安全性和以备需要时进行后续验证。

# 结论

证书颁发机构是对安全性和可靠性有严格要求的基础设施的一个例子。使用本书中概述的最佳实践来实现基础设施可以带来长期的安全性和可靠性。这些原则应该是设计的一部分，但您也应该在系统成熟时使用它们来改进系统。

¹ TLS 的最新版本在[RFC 8446](https://oreil.ly/dB0au)中有描述。

² 安全/多用途互联网邮件扩展是一种加密电子邮件内容的常见方法。

³ 我们意识到许多组织确实构建和运营私有 CA，使用诸如微软的 AD 证书服务等常见解决方案。这些通常仅供内部使用。

⁴ DigiNotar 在遭受攻击者的侵害和滥用其 CA 后[破产了](https://oreil.ly/nwNnG)。

⁵ 域验证指南的良好参考是[CA/Browser Forum 基线要求](https://oreil.ly/OkYRq)。

⁶ [Mitre CVE 数据库](https://cve.mitre.org)中包含了各种 DER 处理程序发现的数百个漏洞。

⁷ Borg 容器在 Verma, Abhishek 等人的 2015 年的论文“Large-Scale Cluster Management at Google with Borg.”中有描述。*Proceedings of the 10th European Conference on Computer Systems*: 1–17\. doi:10.1145/2741948.2741964。

⁸ 例如，[ZLint](https://github.com/zmap/zlint)是一个用 Go 编写的 linter，用于验证证书的内容是否符合 RFC 5280 和 CA/Browser Forum 的要求。
