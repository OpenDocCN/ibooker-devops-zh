# 第五章：面向最小特权的设计

> 原文：[5. Design for Least Privilege](https://google.github.io/building-secure-and-reliable-systems/raw/ch05.html)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)


作者：Oliver Barrett，Aaron Joyner 和 Rory Ward‎

与 Guy Fischman 和 Betsy Beyer 合著

公司通常希望假设他们的工程师有最好的意图，并依赖他们无缺地执行艰巨的任务。这不是一个合理的期望。作为一种思考练习，想想如果你*想*做一些邪恶的事情，你可以对你的组织造成什么样的伤害。你能做什么？你会怎么做？你会被发现吗？你能掩盖你的踪迹吗？或者，即使你的意图是好的，你（或具有等效访问权限的人）可能犯下的最严重错误是什么？在调试、应对故障或执行紧急响应时，你或你的同事使用的多少临时手动命令离造成或加剧故障只有一个打字错误或复制粘贴失败的距离？

因为我们不能依赖人类的完美，我们必须假设任何可能的坏行为或结果都可能发生。因此，我们建议设计系统以最小化或消除这些坏行为的影响。

即使我们通常信任访问我们系统的人类，我们也需要限制他们的特权和我们对他们凭证的信任。事情可能会出错。人们会犯错，误操作命令，被攻击，上当受骗。期望完美是不现实的假设。换句话说，引用 SRE 的格言——希望不是一种策略。

# 概念和术语

在我们深入探讨设计和操作访问控制系统的最佳实践之前，让我们为行业和谷歌使用的一些特定术语建立工作定义。

## 最小特权

*最小特权*是安全行业中已经确立的一个广泛概念。本章的高级最佳实践可以为系统奠定为任何特定任务或行动路径授予最小特权的基础。这一目标适用于分布式系统包括的人类、自动化任务和个别机器。最小特权的目标应该贯穿系统的所有身份验证和授权层。特别是，我们推荐的方法拒绝将隐含的权限扩展给工具（如“工作示例：配置分发”中所示），并努力确保用户尽可能不具有[环境权限](https://oreil.ly/fF_EA)——例如，以 root 用户登录的能力。

## 零信任网络

我们讨论的设计原则始于*零信任网络*——即用户的网络位置（在公司网络内）不授予任何特权访问的概念。例如，在会议室的网络端口插入并不比在互联网其他地方连接获得更多访问权限。相反，系统基于用户凭证和设备凭证的组合来授予访问权限——我们对用户和设备的了解。谷歌通过其[BeyondCorp 计划](https://oreil.ly/8x9OJ)成功实现了大规模的零信任网络模型。

## 零接触

谷歌的 SRE 组织正在努力通过自动化来建立在最小特权概念之上，目标是实现我们所称的*零接触*接口。这些接口的具体目标——比如第三章中描述的零接触生产（ZTP）和零信任网络（ZTN）——是通过工具和自动化使谷歌更安全，减少故障，从而消除人类对生产角色的直接访问。这种方法需要大量的自动化、新的安全 API 和弹性的多方批准系统。

# 基于风险分类访问

任何风险降低策略都伴随着权衡。减少人为因素引入的风险可能需要额外的控制或工程工作，并可能会对生产力产生权衡；它可能会增加工程时间，流程变更，运营工作或机会成本。您可以通过明确定义和优先考虑您想要保护的内容来限制这些成本。

并非所有数据或操作都是平等的，您的访问组成可能会根据系统的性质而有很大不同。因此，您不应该以相同程度保护所有访问。为了应用最合适的控制措施并避免全有或全无的心态，您需要根据影响，安全风险和/或重要性对访问进行分类。例如，您可能需要以不同方式处理对不同类型数据（公开可用数据与公司数据与用户数据与加密密钥）的访问。同样，您可能需要以不同方式处理可以删除数据的管理 API 与特定服务的读取 API。

您的分类应该清晰定义，一贯应用，并广泛理解，以便人们可以设计“讲”这种语言的系统和服务。您的分类框架将根据系统的大小和复杂性而变化：您可能只需要依赖临时标记的两种或三种类型，或者您可能需要一个强大和程序化的系统来对系统的部分（API 分组，数据类型）进行分类。这些分类可能适用于用户在工作过程中可能访问的数据存储，API，服务或其他实体。确保您的框架可以处理系统中最重要的实体。

一旦您建立了分类的基础，您应该考虑每个分类中的控制措施。您需要考虑几个方面：

+   谁应该有访问权限？

+   该访问应该受到多大程度的控制？

+   用户需要什么类型的访问（读/写）？

+   基础设施控制措施是什么？

例如，如表 5-1 所示，一家公司可能需要三种分类：*公开*，*敏感*和*高度敏感*。该公司可能会根据访问如果被不当授予可能造成的损害程度，将安全控制分类为*低风险*，*中风险*或*高风险*。

表 5-1。基于风险的访问分类示例

|  | 描述 | 读取访问 | 写入访问 | 基础设施访问ᵃ |
| --- | --- | --- | --- | --- |
| **公开** | 对公司内任何人开放 | 低风险 | 低风险 | 高风险 |
| **敏感** | 仅限于具有业务目的的群体 | 中/高风险 | 中风险 | 高风险 |
| **高度敏感** | 无永久访问 | 高风险 | 高风险 | 高风险 |
| ᵃ 绕过正常访问控制的管理能力。例如，减少日志级别，更改加密要求，获得对机器的直接 SSH 访问，重新启动和重新配置服务选项，或以其他方式影响服务的可用性。 |

您的目标应该是构建一个访问框架，从中您可以应用适当的控制，以实现生产力，安全性和可靠性的正确平衡。最小特权应该适用于所有数据访问和操作。基于这个基础框架，让我们讨论如何设计具有最小特权原则和控制的系统。

# 最佳实践

在实现最小特权模型时，我们建议遵循这里详细介绍的几项最佳实践。

## 小型功能 API

> 使每个程序都做一件事情。要做一项新工作，最好重新构建，而不是通过添加新的“功能”来使旧程序变得复杂。
>
> ——McIlroy, Pinson, and Tague (1978)¹

正如这句引语所传达的，Unix 文化的核心是围绕着可以组合的小而简单的工具。因为现代分布式计算是从 20 世纪 70 年代的单一时间共享计算系统发展而来的，演变成了全球范围内连接的分布式系统，所以作者的建议在 40 多年后仍然是正确的。为了适应当前的计算环境，人们可能会说，“让每个 API 端点都做好一件事。”在构建系统时，要考虑安全性和可靠性，避免开放式的交互式接口，而是设计小型的功能性 API。这种方法使您能够应用最小权限的经典安全原则，并授予执行特定功能所需的最低权限。

我们所说的*API*究竟是什么意思？每个系统都有一个 API：它只是系统呈现的用户界面。有些 API 非常大（比如 POSIX API 或 Windows API），有些相对较小（比如 memcached 和 NATS），有些非常小（比如 World Clock API、TinyURL 和 Google Fonts API）。当我们谈论分布式系统的 API 时，我们只是指您可以查询或修改其内部状态的所有方式的总和。API 设计在计算文献中已经得到很好的覆盖；本章重点介绍如何通过暴露具有少量明确定义基元的 API 端点来设计和安全地维护安全系统。例如，您评估的输入可能是对唯一 ID 的 CRUD（创建、读取、更新和删除）操作，而不是接受编程语言的 API。

除了面向用户的 API，还要特别关注管理 API。管理 API 对于应用程序的可靠性和安全性同样重要（可以说更重要）。在使用这些 API 时出现拼写错误和错误可能导致灾难性的中断或暴露大量数据。因此，管理 API 也是恶意行为者最感兴趣的攻击面之一。

管理 API 只能由内部用户和工具访问，因此相对于面向用户的 API，它们可能更快速和更容易更改。然而，一旦内部用户和工具开始构建任何 API，更改它仍然会有成本，因此我们建议仔细考虑其设计。管理 API 包括以下内容：

+   设置/拆卸 API，例如用于构建、安装和更新软件或提供其运行的容器的 API

+   维护和紧急 API，例如管理访问以删除损坏的用户数据或状态，或重新启动行为不端的进程

在访问和安全性方面，API 的大小是否重要？考虑一个熟悉的例子：POSIX API，这是我们之前提到的一个非常大的 API。这个 API 很受欢迎，因为它灵活并且为许多人所熟悉。作为一个生产机器管理 API，它通常用于相对明确定义的任务，比如安装软件包、更改配置文件或重新启动守护进程。

用户通常通过交互式的 OpenSSH 会话或使用针对 POSIX API 的脚本工具执行传统的 Unix 主机设置和维护。这两种方法都向调用者公开整个 POSIX API。在交互式会话期间难以限制和审计用户的操作。特别是如果用户恶意尝试规避控制，或者连接的工作站受到损害。

您可以使用各种机制来限制通过 POSIX API 授予用户的权限¹⁰，但这是暴露非常庞大的 API 的基本缺陷。相反，最好将这个庞大的管理 API 减少和分解成更小的部分。然后，您可以遵循最小权限原则，仅授予特定调用者所需的特定操作的权限。

###### 注意

暴露的 POSIX API 不应与 OpenSSH API 混淆。可以利用 OpenSSH 协议及其身份验证、授权和审计（AAA）控件，而无需暴露整个 POSIX API；例如，使用[git-shell](https://oreil.ly/gN12-)。

## 紧急功能

以火警拉环的名字命名，指示用户“在紧急情况下打破玻璃”的*紧急功能机制*在紧急情况下提供对系统的访问，并完全绕过您的授权系统。这对于从意想不到的情况中恢复很有用。有关更多上下文，请参见“优雅失败和紧急功能机制”和“诊断访问拒绝”。

## 审计

*审计*主要用于检测错误的授权使用。这可能包括恶意系统操作员滥用其权力，外部参与者窃取用户凭据，或者恶意软件对另一个系统采取意外行动。您对审计和有意义地检测噪音中的信号的能力在很大程度上取决于您审计的系统的设计：

+   访问控制决策的粒度有多大，或者是否被绕过？（*什么？在哪里？*）

+   您能清楚地捕获与请求相关的元数据吗？（*谁？何时？为什么？*）

以下提示将有助于制定健全的审计策略。最终，您的成功也将取决于与审计相关的文化。

### 收集良好的审计日志

使用小型功能 API（如“小型功能 API”中讨论的）对您的审计能力提供了最大的单一优势。最有用的审计日志捕获了一系列细粒度的操作，例如“推送了一个带有密码哈希 123DEAD...BEEF456 的配置”或“执行了`<x>`命令”。考虑如何向客户显示和证明您的管理操作也有助于使您的审计日志更具描述性，从而在内部更有用。细粒度的审计日志信息使您能够对用户执行或未执行的操作做出强有力的断言，但一定要专注于捕获*有用*部分的操作。

特殊情况需要特殊访问权限，这需要强大的审计文化。如果您发现现有的小型功能 API 界面不足以恢复系统，您有两个选择：

+   提供紧急功能，允许用户打开与强大且灵活的 API 的交互式会话。

+   允许用户以一种无法合理审计其使用情况的方式直接访问凭据。

在这两种情况下，您可能无法构建粒度细致的审计跟踪。记录用户打开与大型 API 的交互式会话并不能有意义地告诉您他们做了什么。一个有动机和知识的内部人员可以轻松地绕过许多捕获交互式会话的会话日志的解决方案，例如记录 bash 命令历史。即使您可以捕获完整的会话记录，有效地审计它可能会非常困难：使用 ncurses 的可视应用程序需要重播才能被人类读取，并且诸如 SSH 多路复用之类的功能可能进一步复杂化捕获和理解交织状态。

对过于宽泛的 API 和/或频繁的紧急访问的解药是培养重视仔细审计的文化。这对可靠性和安全性都至关重要，你可以利用这两种动机来吸引负责任的人。两双眼睛有助于避免拼写错误和错误，你应该始终防范对用户数据的单方面访问。

最终，建立管理 API 和自动化的团队需要以促进审计的方式设计它们。经常访问生产系统的人应该有动力共同解决这些问题，并理解良好审计日志的价值。如果没有文化的强化，审计可能会变成橡皮图章，而紧急访问可能会变成每天的事情，失去了其重要性或紧迫性。文化是确保团队选择、构建和使用支持审计的系统的关键；这些事件只会偶尔发生；审计事件得到应有的审查。

### 选择审计员

一旦你收集了一个良好的审计日志，你需要选择合适的人来检查（希望是罕见的）记录事件。审计员需要具有正确的上下文和正确的目标。

在上下文方面，审计员需要知道特定操作的作用，最好知道执行该操作的原因。因此，审计员通常会是一个队友、经理或熟悉需要执行该操作的工作流程的人。你需要在充分的上下文和客观性之间取得平衡：虽然内部审查员可能与生成审计事件的人有密切的个人关系和/或希望组织取得成功，但外部私人审计员可能希望继续受雇于一个组织。

选择具有正确目标的审计员取决于审计的目的。在谷歌，我们进行两种广泛的审计：

+   审计以确保遵循最佳实践

+   审计以识别安全漏洞

一般来说，“最佳实践”审计支持我们的可靠性目标。例如，一个 SRE 团队可能会选择在每周团队会议期间审计上周的紧急访问事件。这种做法提供了一种文化上的同行压力，以使用和改进更小的服务管理 API，而不是使用紧急使用 API 来访问更灵活的紧急使用 API。广泛范围的紧急访问通常会绕过一些或全部安全检查，使服务面临更高的人为错误风险。

谷歌通常将紧急访问审查下放到团队级别，这样我们就可以利用伴随团队审查的社会规范。进行审查的同行具有上下文，使他们能够发现即使是伪装得很好的行为，这对于防止内部滥用和阻止恶意内部人员至关重要。例如，同事很容易注意到如果一个同事反复使用紧急访问操作来访问一个他们可能实际上并不需要的不寻常资源。这种团队审查还有助于发现管理 API 的不足。当特定任务需要紧急访问时，通常表明需要提供一种更安全或更安全的方式来执行该任务作为正常 API 的一部分。您可以在第二十一章中阅读更多关于这个主题的内容。

在谷歌，我们倾向于集中第二类审计，因为识别外部安全漏洞有利于对组织的广泛视野。一个高级攻击者可能会侵入一个团队，然后利用该访问来侵入另一个团队、服务或角色。每个单独的团队可能不会注意到一些异常的行为，并且没有跨团队的视野来连接不同的行为集。

中央审计团队也可以配备额外的信号和添加代码以进行额外的审计事件，这些事件可能并不广为人知。这些类型的警报在早期检测中可能特别有用，但您可能不希望广泛共享其实现细节。您可能还需要与组织中的其他部门（如法律和人力资源）合作，以确保审计机制是适当的、范围适当的并且有文档记录。

我们在谷歌使用*结构化理由*将审计日志事件与结构化数据关联起来。当发生生成审计日志的事件时，我们可以将其与结构化引用（例如 bug 编号、工单编号或客户案例编号）关联起来。这样做可以让我们构建审计日志的程序检查。例如，如果支持人员查看客户的付款详情或其他敏感数据，他们可以将这些数据与特定客户案例相关联。因此，我们可以确保观察到的数据属于开启案例的客户。如果我们依赖自由文本字段，要自动化日志验证将会更加困难。结构化理由对于扩展我们的审计工作至关重要，它为中央审计团队提供了关键的上下文，对于有效的审计和分析至关重要。

## 测试和最小权限

适当的测试是任何良好设计系统的基本属性。测试在最小权限方面有两个重要的维度：

+   最小权限的测试，以确保访问仅被正确授予必要的资源

+   最小权限的测试，以确保测试基础设施只具有其所需的访问权限

### 最小权限的测试

在最小权限的背景下，您需要能够测试明确定义的用户配置文件（例如，数据分析师、客户支持、SRE）是否具有足够的权限来执行其角色，但不会过多。

您的基础设施应该让您做到以下几点：

+   描述特定用户配置文件在其工作角色中需要能够做什么。这定义了他们在角色中所需的最小访问权限（API 和数据）以及访问类型（读或写，永久或临时）。

+   描述一组场景，在这些场景中，用户配置文件尝试在您的系统上执行操作（例如读取、批量读取、写入、删除、批量删除、管理），并描述对您的系统的预期结果/影响。

+   运行这些场景，并将实际结果/影响与预期结果/影响进行比较。

理想情况下，为了防止对生产系统产生不利影响，这些测试应该在代码或 ACL 更改之前运行。如果测试覆盖不完整，您可以通过监控访问和警报系统来减轻过于广泛的访问。

### 最小权限的测试

测试应该允许您验证预期的读/写行为，而不会危及服务的可靠性、敏感数据或其他关键资产。但是，如果您没有适当的测试基础设施，即考虑到各种环境、客户端、凭证、数据集等的基础设施，那么需要读/写数据或改变服务状态的测试可能会带来风险。

考虑将配置文件推送到生产环境的示例，我们将在下一节中返回到这个示例。在为此配置推送设计测试策略的第一步是提供一个使用自己凭证的单独环境。这样的设置可以确保在编写或执行测试时出现错误不会影响生产环境，例如覆盖生产数据或使生产服务崩溃。

或者，假设您正在开发一个键盘应用程序，允许用户一键发布表情包。您希望分析用户的行为和历史，以便自动推荐表情包。如果缺乏适当的测试基础设施，您需要在生产环境中给数据分析师读/写访问权限，以执行分析和测试。

适当的测试方法应考虑限制用户访问和降低风险的方式，但仍允许数据分析师执行他们需要完成工作的测试。他们需要写入权限吗？您可以使用匿名化的数据集来执行他们需要执行的任务吗？您可以使用测试账户吗？您可以在具有匿名化数据的测试环境中操作吗？如果此访问受到威胁，哪些数据会被暴露？

您可以通过从小处开始来处理测试基础设施——不要让完美成为良好的敌人。首先考虑您最容易实现的方式

+   分离环境和凭证

+   限制访问类型

+   限制数据的暴露

最初，也许您可以在云平台上快速进行短暂的测试，而不是构建整个测试基础设施堆栈。一些员工可能只需要读取或临时访问。在某些情况下，您还可以使用代表性或匿名化的数据集。

虽然这些测试最佳实践在理论上听起来很棒，但在这一点上，您可能会被构建适当的测试基础设施的潜在成本所压倒。做对这件事并不便宜。然而，请考虑没有适当的测试基础设施的成本：您能确定每次关键操作的测试不会导致生产中断吗？您能接受数据分析师具有本来可以避免的访问敏感数据的特权吗？您是否依赖于完美的人类和完美执行的完美测试？

对于您特定的情况，进行适当的成本效益分析非常重要。最初构建“理想”解决方案可能并不合理。但是，请确保您构建的框架会被人们使用。人们需要进行测试。如果您没有提供足够的测试框架，他们将在生产环境中进行测试，绕过您制定的控制措施。

## 诊断访问拒绝

在一个复杂的系统中，最小权限被强制执行，客户必须通过第三方因素、多方授权或其他机制（见“高级控制”）来赢得信任，策略在多个级别和细粒度上被执行。因此，策略拒绝也可能以复杂的方式发生。

考虑一个理智的安全策略正在执行的情况，您的授权系统拒绝访问。可能会出现三种可能的结果之一：

+   客户被正确拒绝，您的系统行为正确。最小权限已被执行，一切都很好。

+   客户被正确拒绝，但可以使用高级控制（如多方授权）来获得临时访问。

+   客户认为他们被错误拒绝了，并可能向您的安全策略团队提交支持工单。例如，如果客户最近被从授权组中移除，或者策略以微妙或可能不正确的方式发生了变化，这可能会发生。

在所有情况下，呼叫者对拒绝的原因一无所知。但系统是否可以向客户提供更多信息？根据呼叫者的权限级别，它可以。

如果客户端没有或权限非常有限，拒绝应该保持盲目 - 您可能不希望暴露 403 访问被拒绝错误代码（或其等效），因为有关拒绝原因的详细信息可能被利用以获取有关系统的信息，甚至找到获得访问权限的方法。但是，如果调用者具有某些最低权限，您可以提供与拒绝相关联的令牌。调用者可以使用该令牌调用高级控件以获取临时访问权限，或通过支持渠道将令牌提供给安全策略团队，以便他们用于诊断问题。对于更具特权的调用者，您可以提供与拒绝相关联的令牌*和*一些纠正信息。然后，调用者可以尝试自行纠正，然后再调用支持渠道。例如，调用者可能会得知访问被拒绝是因为他们需要成为特定组的成员，然后他们可以请求访问该组。

在公开多少纠正信息和安全策略团队可以处理多少支持负载之间总会存在紧张关系。但是，如果您公开了太多信息，客户端可能能够从拒绝信息中重新设计策略，从而使恶意行为者更容易制定使用策略的请求的方式。考虑到这一点，我们建议在实现零信任模型的早期阶段，您使用令牌，并要求所有客户端调用支持渠道。

## 优雅的失败和破玻璃机制

理想情况下，您总是在处理一个实现合理策略的工作授权系统。但实际上，您可能会遇到导致大规模访问拒绝的场景（可能是由于糟糕的系统更新）。作为回应，您需要能够通过破玻璃机制绕过授权系统，以便您可以修复它。

在使用破玻璃机制时，请考虑以下准则：

+   使用破玻璃机制的能力应受到严格限制。通常情况下，它应仅对负责系统运行 SLA 的 SRE 团队可用。

+   零信任网络的破玻璃机制应仅在特定位置可用。这些位置是您的*恐慌室*，具有额外物理访问控制的特定位置，以抵消其连接性所放置的增加信任。 （细心的读者会注意到，零信任网络的备用机制是不信任网络位置的策略，实际上是信任网络位置，但具有额外的物理访问控制。）

+   所有使用破玻璃机制的情况都应受到密切监控。

+   破玻璃机制应该由负责生产服务的团队定期测试，以确保在需要时它能正常运行。

当成功利用破玻璃机制使用户恢复访问权限时，您的 SREs 和安全策略团队可以进一步诊断和解决潜在问题。第八章和第九章讨论了相关策略。

# 工作示例：配置分发

让我们来看一个现实世界的例子。将配置文件分发给一组 Web 服务器是一个有趣的设计问题，可以通过一个小型的功能 API 实际实现。管理配置文件的最佳实践是：

1.  将配置文件存储在版本控制系统中。

1.  对文件进行代码审查更改。

1.  首先自动将配置文件分发给一组金丝雀，对金丝雀进行健康检查，然后在逐渐将文件推送到 Web 服务器群中继续对所有主机进行健康检查。这一步需要授予自动化访问权限以远程更新配置文件。

有许多方法可以公开一个小型 API，每种方法都针对更新 Web 服务器配置的功能进行了定制。表 5-2 总结了您可能考虑的一些 API 及其权衡。接下来的部分将更深入地解释每种策略。

表 5-2\. 更新 Web 服务器配置的 API 及其权衡

|  | 通过 OpenSSH 的 POSIX API | 软件更新 API | 自定义 OpenSSH ForceCommand | 自定义 HTTP 接收器 |
| --- | --- | --- | --- | --- |
| **API 表面** | 大 | 各种 | 小 | 小 |
| **现有的**ᵃ | 可能 | 是 | 不太可能 | 不太可能 |
| **复杂性** | 高 | 高 | 低 | 中等 |
| **可扩展性** | 中等 | 中等，但可重复使用 | 困难 | 中等 |
| **可审计性** | 差 | 好 | 好 | 好 |
| **可以表达最小特权** | 差 | 各种 | 好 | 好 |
| ᵃ 这表明您已经拥有或不太可能拥有这种类型的 API 作为现有 Web 服务器部署的一部分。 |

## 通过 OpenSSH 的 POSIX API

您可以允许自动化通过 OpenSSH 连接到 Web 服务器主机，通常以 Web 服务器运行的本地用户身份连接。然后，自动化可以编写配置文件并重新启动 Web 服务器进程。这种模式简单且常见。它利用了可能已经存在的管理 API，因此需要很少的额外代码。不幸的是，利用大型现有的管理 API 会引入一些风险：

+   运行自动化的角色可以永久停止 Web 服务器，启动另一个二进制文件代替它，读取其访问权限下的任何数据等。

+   自动化中的错误隐含地具有足够的访问权限，可以导致所有 Web 服务器的协调停机。

+   自动化凭据的妥协等同于所有 Web 服务器的妥协。

## 软件更新 API

您可以将配置作为打包的软件更新分发，使用与更新 Web 服务器二进制相同的机制。有许多打包和触发二进制更新的方法，使用不同大小的 API。一个简单的例子是从中央仓库拉取的 Debian 软件包（*.deb*），由`cron`调用的周期性`apt-get`。您可以构建一个更复杂的示例，使用以下部分讨论的模式之一来触发更新（而不是使用`cron`），然后可以重用该更新来更新配置和二进制文件。随着您不断完善二进制分发机制以增加安全性和安全性，这些好处也会应用到配置上，因为两者使用相同的基础设施。为了集中协调金丝雀流程、协调健康检查或提供签名/来源/审计等工作同样对这两种工件都有好处。

有时，二进制和配置更新系统的需求不一致。例如，您可能在配置中分发一个 IP 拒绝列表，需要尽快收敛，同时将 Web 服务器二进制构建到容器中。在这种情况下，以您希望分发配置更新的速度建立、启动和关闭一个新的容器可能太昂贵或具有破坏性。这种类型的冲突要求可能需要两种分发机制：一种用于二进制文件，另一种用于配置更新。

有关此模式的更多想法，请参见第九章。

## 自定义 OpenSSH ForceCommand

您可以编写一个简短的脚本来执行这些步骤：

1.  从`STDIN`接收配置。

1.  对配置进行合理性检查。

1.  重新启动 Web 服务器以更新配置。

然后，您可以通过在*authorized_keys*文件中绑定特定条目与`ForceCommand`选项来通过 OpenSSH 公开此命令。¹² 这种策略向调用者呈现了一个非常小的 API，可以通过经过严格测试的 OpenSSH 协议连接，其中唯一可用的操作是提供配置文件的副本。记录文件（或其哈希值^(13））合理地捕获了会话的整个操作，以供以后审计。

您可以实现尽可能多的这些唯一的密钥/`ForceCommand`组合，但是这种模式很难扩展到许多唯一的管理操作。虽然您可以在 OpenSSH API 的基础上构建基于文本的协议（例如[git-shell](https://oreil.ly/k4igi)），但这样做将开始构建自己的 RPC 机制。您可能最好直接跳到该道路的尽头，构建在现有框架（如[gRPC](https://grpc.io)或[Thrift](https://thrift.apache.org)）之上。

## 自定义 HTTP 接收器（边车）

您可以编写一个小的边车守护程序——非常类似于`ForceCommand`解决方案，但使用另一个 AAA 机制（例如，带 SSL 的 gRPC，[SPIFFE](https://spiffe.io)或类似机制）——来接受配置。这种方法不需要修改服务二进制文件，非常灵活，但需要引入更多的代码和另一个守护程序来管理。

## 自定义 HTTP 接收器（进程内）

您还可以修改 Web 服务器以[直接公开 API 来更新其配置](https://oreil.ly/hu7yg)，接收配置并将其写入磁盘。这是最灵活的方法之一，与我们在 Google 管理配置的方式非常相似，但需要将代码合并到服务二进制文件中。

## 权衡

除了表 5-2 中的大选项外，其他选项都提供了向自动化添加安全性和安全性的机会。攻击者仍然可能通过推送任意配置来破坏 Web 服务器的角色；但是，选择较小的 API 意味着推送机制不会隐含允许这种妥协。

您可能还可以通过独立于推送它的自动化对配置进行签名来进一步设计最小特权。这种策略将信任分割为角色之间的信任，保证如果推送配置的自动化角色受到破坏，自动化也不能通过发送恶意配置来破坏 Web 服务器。回想麦克罗伊、平森和塔格的建议，设计系统的每个部分执行一个任务并且执行得很好，可以让您隔离信任。

狭窄 API 呈现的更精细的控制界面还允许您添加对自动化中的错误的保护。除了需要签名来验证配置之外，您还可以要求从中央速率限制器获取持有者令牌¹⁴，该速率限制器独立于您的自动化创建，并针对推出的每个主机。您可以非常小心地对这个通用速率限制器进行单元测试；如果速率限制器是独立实现的，那么可能不会同时影响推出自动化的错误也不会影响它。独立的速率限制器也可以方便地重复使用，因为它可以对 Web 服务器的配置推出进行速率限制，对相同服务器的二进制推出进行速率限制，对服务器的重新启动进行速率限制，或者对您希望添加安全检查的任何其他任务进行速率限制。

# 用于认证和授权决策的策略框架

> *认证* [名词]：验证用户或进程的**身份**
>
> *授权* [名词]：评估特定经过身份验证的一方的请求**是否应该被允许**

前一节提倡为您的服务设计一个狭窄的管理 API，这样您可以授予尽可能少的特权来实现给定的操作。一旦存在该 API，您必须决定如何控制对其的访问。访问控制涉及两个重要但不同的步骤。

首先，您必须*验证*谁在连接。认证机制的复杂程度可以不同：

简单：接受通过 URL 参数传递的用户名

示例：*/service?username=admin*

更复杂：呈现预共享密钥

示例：WPA2-PSK，HTTP cookie

更复杂：复杂的混合加密和证书方案

示例：TLS 1.3，OAuth

一般来说，您应该更倾向于重用现有的强大的加密身份验证机制来识别 API 的调用者。这个身份验证决定的结果通常表示为用户名、常用名称、“主体”、“角色”等。在本节中，我们使用*角色*来描述身份验证的可互换结果。

接下来，您的代码必须做出决定：这个角色是否*被授权*执行所请求的操作？您的代码可能会考虑请求的许多属性，例如以下内容：

所请求的具体操作

示例：URL，正在运行的命令，gRPC 方法

请求的操作参数

示例：URL 参数，`argv`，gRPC 请求

请求的来源

示例：IP 地址，客户端证书元数据

经过身份验证的角色的元数据

示例：地理位置，法律管辖区，风险的机器学习评估

服务器端上下文

示例：类似请求的速率，可用容量

本节的其余部分讨论了谷歌发现有用的几种技术，以改进和扩展身份验证和授权决策的基本要求。

## 使用高级授权控制

给定资源的访问控制列表是实现授权决策的一种熟悉方式。最简单的 ACL 是与经过身份验证的角色匹配的字符串，通常与某种分组概念结合在一起，例如一组角色，例如“管理员”，它扩展为更大的角色列表，例如用户名。当服务评估传入请求时，它会检查经过身份验证的角色是否是 ACL 的成员。

更复杂的授权要求，例如多因素授权（MFA）或多方授权（MPA），需要更复杂的授权代码（有关三因素授权和 MPA 的更多信息，请参见“高级控制”）。此外，一些组织在设计授权策略时可能需要考虑其特定的监管或合同要求。

这段代码很难正确实现，如果许多服务都实现了自己的授权逻辑，其复杂性可能会迅速增加。根据我们的经验，使用像[AWS](https://aws.amazon.com/iam)或[GCP](https://cloud.google.com/iam)身份和访问管理（IAM）等框架可以将授权决策的复杂性与核心 API 设计和业务逻辑分离。在谷歌，我们还广泛使用 GCP 授权框架的变体来内部服务。¹⁵

安全策略框架允许我们的代码进行简单的检查（例如“X 是否可以访问资源 Y？”），并将这些检查与外部提供的策略进行评估。如果我们需要向特定操作添加更多的授权控制，我们可以简单地更改相关的策略配置文件。这种低开销具有巨大的功能和速度优势。

## 投资于广泛使用的授权框架

您可以通过使用共享库实现授权决策，并尽可能广泛地使用一致的接口来实现规模化的身份验证和授权更改。在安全领域应用这一经典的模块化软件设计建议会产生意想不到的好处。例如：

+   您可以通过单个库更改为所有服务端点添加对 MFA 或 MPA 的支持。

+   然后，您可以通过单个配置更改在所有服务中的少量操作或资源上实现此支持。

+   通过要求所有允许潜在不安全操作的操作都需要 MPA，您可以提高可靠性，类似于代码审查系统。这种流程改进可以提高对内部风险威胁的安全性（有关对手类型的更多信息，请参见第二章），通过促进快速事件响应（绕过修订控制系统和代码审查依赖）而不允许广泛的单方面访问。

随着组织的发展，标准化是您的朋友。统一的授权框架有助于团队流动性，因为更多的人知道如何使用共同的框架编写代码并实现访问控制。

## 避免潜在陷阱

设计复杂的授权策略语言是困难的。如果策略语言过于简单，它将无法实现其目标，并且您最终将授权决策分散在框架策略和主要代码库中。如果策略语言过于一般化，它将非常难以理解。为了减轻这些问题，您可以应用标准的软件 API 设计实践，特别是迭代设计方法，但我们建议谨慎进行，以避免这两个极端。

仔细考虑授权策略是如何与二进制文件一起交付的。您可能希望更新授权策略，这可能会成为配置中最敏感的部分之一，独立于二进制文件。有关配置分发的更多讨论，请参见本书的上一节中的示例，第九章和第十四章，[SRE 书](https://landing.google.com/sre/sre-book/chapters/release-engineering/)中的第八章，以及[SRE 工作手册](https://landing.google.com/sre/workbook/chapters/configuration-design/)中的第十四章和第十五章。

应用程序开发人员将需要协助制定将编码在此语言中的策略决策。即使您避免了这里描述的陷阱，并创建了一种富有表现力和易于理解的策略语言，往往仍需要应用程序开发人员实现管理 API 和具有关于生产环境的特定领域知识的安全工程师和 SRE 之间的合作，以在安全性和功能性之间找到合适的平衡。

# 深入探讨：高级控制

虽然许多授权决策是二进制的是/否，但在某些情况下更灵活性是有用的。与其要求严格的是/否，不如配备一个“可能”的逃生阀，再加上额外的检查，可以极大地减轻系统的压力。这里描述的许多控制可以单独使用或组合使用。适当的使用取决于数据的敏感性，行动的风险以及现有的业务流程。

## 多方授权（MPA）

引入另一个人是确保正确访问决策的一种经典方式，培养安全和可靠性文化（参见第二十一章）。这种策略提供了几个好处：

+   *防止错误*或意外违反可能导致安全或隐私问题的策略。

+   *阻止恶意行为者*尝试进行恶意更改。这包括员工，他们面临纪律行动的风险，以及外部攻击者，他们面临被发现的风险。

+   通过要求至少牵涉到另一个人的妥协或经过仔细构建的更改经过同行审查，可以*增加攻击的成本*。

+   *审计过去的行动*，以进行事件响应或事后分析，假设审查是永久记录并以防篡改的方式记录的。

+   *提供客户舒适感*。您的客户可能更愿意使用您的服务，因为他们知道没有单个人可以独自进行更改。

MPA 通常用于广泛的访问级别，例如要求批准加入一个授予对生产资源访问权限的组，或者扮演特定角色或凭证的能力。广泛的 MPA 可以作为一个有价值的紧急机制，以启用非常不寻常的操作，对于这些操作你可能没有特定的工作流程。在可能的情况下，你应该尽量提供更细粒度的授权，这可以提供更强的可靠性和安全性保证。如果第二方批准针对小型功能 API 的操作（见[“小型功能 API”]），他们可以更加确信他们正在授权的内容。

关于批准的社会压力也可能导致糟糕的决定。例如，如果一个工程师不愿意拒绝一个可疑请求，因为它是由经理、高级工程师或者站在他们办公桌旁的人发出的。为了减轻这些压力，你可以提供将批准事后升级给安全或调查团队的选项。或者，你可以制定一个政策，要求某种类型的批准全部（或一部分）独立审计。

在构建多方授权系统之前，确保技术和社会动态允许某人说不。否则，系统就没有多少价值。

## 三因素授权（3FA）

在大型组织中，MPA 通常存在一个关键弱点，可以被决心和坚持的攻击者利用：所有的“多方”使用同一台中央管理的工作站。工作站车队越同质化，攻击者就越有可能攻击一台工作站就能攻击几台甚至全部工作站。

一种经典的方法是为了加固工作站车队免受攻击，用户需要维护两个完全独立的工作站：一个用于一般用途，比如浏览网页和发送/接收电子邮件，另一个更可信的工作站用于与生产环境通信。根据我们的经验，用户最终希望这些工作站具有类似的功能和能力，为了维护这些需要更高级别保护的有限用户集的两套工作站基础设施，既昂贵又难以长期维持。一旦这个问题不再是管理层关注的焦点，人们就没有动力去维护这些基础设施。

减轻单个受损平台可能破坏所有授权的风险需要以下措施：

+   至少维护两个平台

+   在两个平台上批准请求的能力

+   （最好）至少有一个平台具有硬化能力

考虑到这些要求，另一个选择是要求从一个硬化的移动平台对某些非常危险的操作进行授权。为了简单和方便起见，你只允许 RPCs 从完全管理的桌面工作站发起，然后要求移动平台进行三因素授权。当一个生产服务接收到一个敏感的 RPC 时，策略框架（在[“用于认证和授权决策的策略框架”]中描述）要求从独立的 3FA 服务获得加密签名的批准。然后该服务指示它将 RPC 发送到移动设备，显示给发起用户，并且他们确认了请求。

硬化移动平台比硬化通用工作站要容易一些。我们发现用户通常更容忍移动设备上的某些安全限制，比如额外的网络监控，只允许一部分应用程序，并且只能连接有限数量的 HTTP 端点。这些策略在现代移动平台上也很容易实现。

一旦您有了一个坚固的移动平台来显示拟议的生产变更，您必须将请求发送到该平台并显示给用户。在谷歌，我们重用了将通知传递到安卓手机的基础设施，以授权和报告我们用户的谷歌登录尝试。如果您有类似的坚固基础设施，那么将其扩展以支持此用例可能是有用的，但如果没有，基本的基于网络的解决方案相对容易创建。3FA 系统的核心是一个简单的 RPC 服务，它接收要授权的请求，并通过受信任的客户端公开请求以进行授权。请求 3FA 受保护的 RPC 的用户会从其移动设备访问 3FA 服务的网络 URL，并收到授权请求。

重要的是要区分 MPA 和 3FA 保护的威胁，以便您可以决定何时应用一致的策略。MPA 不仅保护免受单方面内部风险的威胁，还保护免受个人工作站的妥协（通过需要第二次内部批准）。3FA 保护免受内部工作站的广泛妥协，但在单独使用时不提供任何对内部威胁的保护。要求发起者进行 3FA，并要求第二方进行简单的基于网络的 MPA，可以提供对大多数这些威胁的组合的非常强大的防御，而组织开销相对较小。

## 业务理由

如“选择审计员”中所述，您可以通过将访问权限与结构化的业务理由（例如错误、事件、工单、案例 ID 或分配的帐户）联系起来来强制执行授权。但是构建验证逻辑可能需要额外的工作，也可能需要对值班或客户服务人员进行流程更改。

例如，考虑客户服务工作流程。在一些小型或不成熟组织中有时会发现的反模式中，基本和初期的系统可能会给客户服务代表访问所有客户记录，要么是出于效率原因，要么是因为不存在控制。更好的选择是默认情况下阻止访问，并且只有在您可以验证业务需求时才允许访问特定数据。这种方法可能是随时间实现的控制梯度。例如，它可能从仅允许分配了一个开放工单的客户服务代表开始。随着时间的推移，您可以改进系统，仅允许访问特定客户以及这些客户的特定数据，并且在经过一段时间后需要客户批准。

当正确配置时，这种策略可以提供强大的授权保证，以确保访问是适当的并且范围适当。结构化的理由允许自动化要求 Ticket #12345 不是随意输入的随机数字，以满足简单的正则表达式检查。相反，理由满足一组平衡运营业务需求和系统能力的访问策略。

## 临时访问

您可以通过向资源授予临时访问来限制授权决策的风险。当没有针对每个操作的细粒度控制时，这种策略通常是有用的，但您仍希望尽可能使用可用的工具授予最低特权。

您可以以结构化和计划的方式（例如，在值班轮换期间或通过过期的组成员资格）或按需方式授予临时访问（用户明确请求访问）来授予临时访问。您还可以将临时访问与多方授权请求、业务理由或其他授权控制结合使用。临时访问还创建了一个逻辑点进行审计，因为您可以清楚地记录任何给定时间具有访问权限的用户。它还提供了关于临时访问发生位置的数据，因此您可以随时间优先处理并减少这些请求。

临时访问还会减少环境权限。这是管理员更喜欢使用`sudo`或“以管理员身份运行”而不是作为 Unix 用户*root*或 Windows 管理员帐户操作的一个原因——当您意外地发出删除所有数据的命令时，您拥有的权限越少，越好！

## 代理

当后端服务的细粒度控制不可用时，您可以退而使用受到严格监控和限制的代理机器（或*堡垒*）。只有来自这些指定代理的请求才被允许访问敏感服务。该代理可以限制危险操作，限制操作速度，并执行更高级的日志记录。

例如，您可能需要执行紧急回滚以撤销错误的更改。鉴于错误更改可能发生的无限方式，以及解决错误更改可能的无限方式，执行回滚所需的步骤可能不会在预定义的 API 或工具中提供。您可以给系统管理员灵活性来解决紧急情况，但引入限制或额外的控制以减轻风险。例如：

+   每个命令可能需要同行批准。

+   管理员可能只连接到相关的机器。

+   管理员使用的计算机可能无法访问互联网。

+   您可以启用更彻底的日志记录。

与此同时，实现任何这些控制都会带来集成和运营成本，如下一节所讨论的。

# 权衡和紧张关系

采用最小权限访问模型肯定会改善您组织的安全姿态。然而，您必须权衡前面部分中概述的好处与实现该姿态的潜在成本。本节考虑了其中一些成本。

## 增加安全复杂性

高度细粒度的安全姿态是一个非常强大的工具，但也很复杂，因此难以管理。拥有一套全面的工具和基础设施来帮助您定义、管理、分析、推送和调试安全策略非常重要。否则，这种复杂性可能变得令人不堪重负。您应该始终力求能够回答这些基本问题：“给定用户是否有权访问给定服务/数据？”和“对于给定服务/数据，谁有权限访问？”

## 对协作和公司文化的影响

虽然最小权限模型可能适用于敏感数据和服务，但在其他领域采取更宽松的方法可以提供切实的好处。

例如，为软件工程师提供对源代码的广泛访问权带来一定的风险。然而，这可以通过工程师能够根据自己的好奇心在工作中学习，并在能够借用他们的注意力和专业知识时在正常角色之外贡献功能和错误修复来平衡。更不明显的是，这种透明度也使工程师更难以编写不合适的代码而不被注意到。

在您的数据分类工作中包括源代码和相关工件可以帮助您形成一个有原则的方法来保护敏感资产，同时又能从对不太敏感资产的可见性中受益，您可以在第二十一章中了解更多。

## 影响安全的高质量数据和系统

在零信任环境中，最小特权的基础上，每个细粒度的安全决策都取决于两件事：正在执行的策略和请求的上下文。*上下文*受到大量数据的影响，其中一些可能是动态的，这些数据可能会影响决策。例如，数据可能包括用户的角色、用户所属的组、发出请求的客户端的属性、输入到机器学习模型的训练集，或者被访问的 API 的敏感性。您应该审查产生这些数据的系统，以确保安全影响数据的质量尽可能高。低质量的数据将导致不正确的安全决策。

## 对用户生产力的影响

您的用户需要尽可能高效地完成其工作流程。最佳的安全姿态是您的最终用户不会注意到的。然而，引入新的三因素和多方授权步骤可能会影响用户的生产力，特别是如果用户必须等待获得授权。您可以通过确保新步骤易于导航来减轻用户的痛苦。同样，最终用户需要一种简单的方式来理解访问拒绝，可以通过自助诊断或快速访问支持渠道。

## 对开发人员复杂性的影响

随着最小特权模型在您的组织中得到采用，开发人员必须遵守它。这些概念和政策必须易于被不太懂安全的开发人员消化，因此您应该提供培训材料并充分记录您的 API。在他们应对新要求时，为开发人员提供便捷快速地访问安全工程师进行安全审查和一般咨询。在这种环境中部署第三方软件需要特别小心，因为您可能需要将软件包装在一个可以执行安全策略的层中。

# 结论

在设计复杂系统时，最小特权模型是确保客户能够完成所需工作，但不多的最安全方式。这是一种强大的设计范式，可以保护您的系统和数据免受已知或未知用户造成的恶意或意外损害。谷歌已经花费了大量时间和精力来实现这个模型。以下是关键组件：

+   对系统功能的全面了解，以便根据每个部分的安全风险水平对其进行分类。

+   基于这种分类，对系统和数据进行尽可能细致的分区。最小特权需要小型功能 API。

+   用于验证用户凭据的身份验证系统，当他们尝试访问您的系统时。

+   强制执行明确定义的安全策略的授权系统，可以轻松附加到您的精细分区系统上。

+   一套用于微妙授权的高级控制。例如，这些控制可以提供临时、多因素和多方批准。

+   系统支持这些关键概念的操作要求。至少，您的系统需要以下内容：

+   审计所有访问并生成信号，以便您可以识别威胁并进行历史取证分析。

+   推理、定义、测试和调试安全策略的手段，并为此策略提供最终用户支持

+   当您的系统表现不如预期时，提供一个紧急访问机制

使所有这些组件以对用户和开发人员易于采用的方式工作，并且不会对其生产力产生显着影响，还需要组织承诺尽可能无缝地采用最低特权。这一承诺包括一个专注的安全功能，通过安全咨询、策略定义、威胁检测和安全相关问题的支持，拥有您的安全姿态并与用户和开发人员进行接口。

虽然这可能是一项艰巨的任务，但我们坚信这是对安全姿态执行现有方法的重大改进。

McIlroy, M.D., E.N. Pinson, and B.A. Tague. 1978\. “UNIX Time-Sharing System: Foreword.” *The Bell System Technical Journal* 57(6): 1899–1904\. doi:10.1002/j.1538-7305.1978.tb02135.x。

POSIX 代表可移植操作系统接口，是由大多数 Unix 变体提供的 IEEE 标准化接口。有关概述，请参阅[Wikipedia](https://oreil.ly/4vLTI)。

Windows API 包括熟悉的图形元素，以及编程接口，如[DirectX](https://oreil.ly/TnmPu)、[COM](https://oreil.ly/PzTUF)等。

[Memcached](https://memcached.org)是一个高性能的分布式内存对象缓存系统。

[NATS](https://oreil.ly/baCc4)是一个基于文本协议构建的基本 API 的示例，而不是像 gRPC 这样的复杂 RPC 接口。

[TinyURL.com](http://TinyURL.com) API 文档不够完善，但它本质上是一个返回缩短 URL 作为响应主体的单个 GET URL。这是一个具有微小 API 的可变服务的罕见示例。

[Fonts API](https://oreil.ly/-Z4F4)只是列出当前可用的字体。它只有一个端点。

一个很好的起点是 Gamma, Erich et al. 1994\. *Design Patterns: Elements of Reusable Object-Oriented Software*. Boston, MA: Addison-Wesley. 另请参阅 Bloch, Joshua. 2006\. “How to Design a Good API and Why It Matters.” *Companion to the 21st ACM SIGPLAN Symposium on Object-Oriented Programming Systems, Languages, and Applications*: 506–507\. doi:10.1145/1176617.1176622。

尽管我们以 Unix 主机为例，但这种模式并不局限于 Unix。传统的 Windows 主机设置和管理遵循类似的模型，其中 Windows API 的交互暴露通常是通过 RDP 而不是 OpenSSH。

流行的选项包括以非特权用户身份运行，然后通过`sudo`对允许的命令进行编码，仅授予必要的[`capabilities(7)`](https://oreil.ly/7Zf70)，或者使用类似 SELinux 的框架。

*Canarying*是指将更改慢慢地推出到生产环境，从一小部分生产端点开始。就像煤矿中的金丝雀一样，它会在出现问题时提供警告信号。有关更多信息，请参阅[SRE 书中的第 27 章](https://landing.google.com/sre/sre-book/chapters/reliable-product-launches)。

`ForceCommand`是一种配置选项，用于限制特定授权身份仅运行单个命令。有关更多详细信息，请参阅[*sshd_config* manpage](https://oreil.ly/4ruSh)。

¹³ 在规模上，记录和存储许多重复文件副本可能是不切实际的。记录哈希值可以让您将配置关联回修订控制系统，并在审计日志中检测未知或意外的配置。作为额外的保险，如果空间允许，您可能希望存储被拒绝的配置，以帮助进行后续调查。理想情况下，所有配置应该被签名，表明它们来自具有已知哈希值的修订控制系统，或者被拒绝。

¹⁴ *持票令牌*只是一个由速率限制器签名的加密签名，可以呈现给任何人，该人具有速率限制器的公钥。他们可以使用该公钥验证速率限制器在令牌的有效期内批准了此操作。

¹⁵ 我们的内部变体支持我们的内部身份验证原语，避免了一些循环依赖的问题等。

¹⁶ 参见“用于身份验证和授权决策的策略框架”。
