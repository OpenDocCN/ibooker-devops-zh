# 第四章：设计权衡

> 原文：[4. Design Tradeoffs](https://google.github.io/building-secure-and-reliable-systems/raw/ch04.html)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)


由 Christoph Kern

与 Brian Gustafson，Paul Blankinship 和 Felix Gröbert 合作

所以你要构建一个（软件）产品！在这个复杂的旅程中，你会有很多事情要考虑，从制定高层计划到部署代码。

通常，你会对产品或服务要做什么有一个大致的想法。例如，这可能是一个游戏的高层概念，或者是基于云的生产力应用的高层业务需求。你还会制定关于服务提供方式的高层计划。

当你深入设计过程，对产品形状的想法变得更加具体时，对应用程序的设计和实现会出现额外的需求和约束。产品的功能性将有特定的需求，还有一般的约束，比如开发和运营成本。你还会遇到安全性和可靠性的需求和约束：你的服务可能会有一定的可用性和可靠性需求，你可能会有保护应用程序处理的敏感用户数据的安全性需求。

其中一些需求和约束可能会相互冲突，你需要做出权衡，并找到它们之间的平衡。

# 设计目标和需求

产品的功能需求往往具有与安全性和可靠性需求显着不同的特征。让我们更仔细地看看在设计产品时你将面临的需求类型。

## 功能需求

*功能需求*，也称为*功能性需求*，¹标识了服务或应用程序的主要功能，并描述了用户如何完成特定任务或满足特定需求。它们通常以*用例*、*用户故事*或[*用户旅程*](https://oreil.ly/yFvEU)的形式表达——用户与服务或应用程序之间的交互序列。*关键需求*是功能需求的子集，对产品或服务至关重要。如果设计不满足关键需求或关键用户故事，那么你就没有一个可行的产品。

功能需求通常是你设计决策的主要驱动因素。毕竟，你正在尝试构建一个满足特定一组用户需求的系统或服务。你经常需要在各种需求之间做出权衡决策。考虑到这一点，区分关键需求和其他功能需求是有用的。

通常，许多需求适用于整个应用程序或服务。这些需求通常不会出现在用户故事或个别功能需求中。相反，它们在集中的需求文档中一次性陈述，甚至是隐含地假定。这里有一个例子：

应用程序的 Web UI 的所有视图/页面必须：

+   遵循常见的视觉设计指南

+   遵守无障碍指南

+   在页脚上加上链接，链接到隐私政策和服务条款（Terms of Service）

## 非功能性需求

几类需求关注的是系统的一般属性或行为，而不是特定的行为。这些*非功能性需求*与我们的关注——安全性和可靠性相关。例如：

+   在哪些独特的情况下，某人（外部用户、客户支持代理或运维工程师）可以访问某些数据？

+   对于诸如正常运行时间或 95th 百分位和 99th 百分位响应延迟等指标的[服务水平目标（SLOs）](https://oreil.ly/EJNnj)是什么？系统在超过某个阈值的负载下如何响应？

在平衡要求时，同时考虑系统本身以外领域的要求可能会有所帮助，因为这些领域的选择可能会对核心系统要求产生重大影响。这些更广泛的领域包括以下内容：

开发效率和速度

考虑到所选择的实现语言、应用程序框架、测试流程和构建流程，开发人员能够多有效地迭代新功能吗？开发人员能够多有效地理解、修改或调试现有代码吗？

部署速度

从功能开发到该功能对用户/客户可用需要多长时间？

## 功能与紧急属性

功能要求通常在要求、满足这些要求的代码和验证实现的测试之间有着相当直接的联系。例如：

规范

用户故事或需求可能规定了应用程序的已登录用户如何查看和修改与其用户配置文件相关的个人数据（例如姓名和联系信息）。

实现

基于此规范的 Web 或移动应用程序通常会有与该要求非常相关的代码，例如以下内容：

+   结构化类型来表示配置文件数据

+   UI 代码来呈现和允许修改配置文件数据

+   服务器端 RPC 或 HTTP 操作处理程序从数据存储中查询已登录用户的配置文件数据，并接受要写入数据存储的更新信息

验证

通常会有一个集成测试，基本上逐步执行指定的用户故事。测试可能使用 UI 测试驱动程序填写并提交“编辑配置文件”表单，然后验证提交的数据是否出现在预期的数据库记录中。该用户故事的各个步骤可能还有单元测试。

相比之下，像可靠性和安全性要求这样的非功能性要求往往更难以确定。如果您的 Web 服务器有一个`--enable_high_reliability_mode`标志，而要使您的应用程序可靠，您只需要翻转该标志并支付您的托管或云提供商高级服务费就可以了。但是没有这样的标志，也没有任何应用程序源代码中“实现”可靠性的特定模块或组件。

## 例如：谷歌设计文档

谷歌使用设计文档模板来指导新功能设计，并在启动工程项目之前收集利益相关者的反馈意见。

与可靠性和安全性考虑相关的模板部分提醒团队考虑其项目的影响，并在适当的情况下启动生产准备或安全审查流程。设计审查有时会在工程师正式开始考虑启动阶段之前的多个季度进行。

# 平衡要求

由于满足安全性和可靠性要求的系统属性很大程度上是紧急属性，它们往往既与功能要求的实现相互作用，又与彼此相互作用。因此，很难单独推理涉及安全性和可靠性的权衡。

本节提供了一个示例，说明了您可能需要考虑的权衡。这个示例的一些部分深入到技术细节，这些细节本身并不一定重要。设计支付处理系统及其运作所涉及的所有合规性、监管、法律和商业考虑对于这个示例也不重要。相反，目的是说明要求之间复杂相互依赖的思维过程。换句话说，重点不是保护信用卡号的细枝末节，而是设计具有复杂安全性和可靠性要求的系统所需的思维过程。

## 示例：支付处理

想象一下，你正在构建一个在线服务，向消费者销售小部件。该服务的规范包括一个用户故事，规定用户可以通过使用移动或网络应用程序从在线目录中选择小部件。然后用户可以购买所选的小部件，这需要他们提供付款方式的详细信息。

### 安全性和可靠性考虑

接受付款信息会为系统的设计和组织流程引入重大的安全性和可靠性考虑。姓名、地址和信用卡号码是需要特殊保护的敏感个人数据，并且根据适用的司法管辖区，可能会使您的系统受到监管标准的约束。接受付款信息还可能使服务受到符合行业或监管安全标准（如 PCI DSS）的合规范围。

对这些敏感用户信息的妥协，尤其是个人可识别信息（PII），可能会对项目甚至整个组织/公司产生严重后果。您可能会失去用户和客户的信任，并因此失去他们的业务。近年来，立法机构已颁布了法律和法规，对受数据泄露影响的公司施加了可能耗时和昂贵的义务。一些公司甚至因严重的安全事件而完全倒闭，如第一章所述。

在某些情况下，产品设计层面的更高级别权衡可能会使应用程序摆脱处理支付的需求，例如，也许产品可以以基于广告或社区资助的模式重塑。对于我们的例子，我们将坚持接受付款是一个关键要求的前提。

### 使用第三方服务提供商处理敏感数据

通常，减轻对敏感数据的安全担忧的最佳方法是根本不保存这些数据（有关此主题的更多信息，请参见第五章）。您可以安排敏感数据永远不会通过您的系统，或者至少设计系统不会持久存储数据。您可以选择各种商业支付服务 API 与应用程序集成，并将支付信息、支付交易和相关问题（如欺诈对策）的处理外包给供应商。

#### 好处

根据情况，使用支付服务可能会降低风险，并减少您需要在这一领域建立内部专业知识的程度，而是依赖供应商的专业知识：

+   您的系统不再保存敏感数据，减少了系统或流程中的漏洞可能导致数据泄露的风险。当然，第三方供应商的妥协仍可能危及您的用户数据。

+   根据具体情况和适用要求，您在支付行业安全标准下的合同和合规义务可能会简化。

+   您无需构建和维护基础设施来保护系统数据存储中的数据。这可能消除了大量的开发和持续运营工作。

+   许多第三方支付提供商提供对抗欺诈交易和支付风险评估服务。您可以使用这些功能来减少支付欺诈风险，而无需自行构建和维护基础设施。

另一方面，依赖第三方服务提供商会带来自己的成本和风险。

#### 成本和非技术风险

显然，供应商将收取费用。交易量可能会影响你的选择 - 超过一定量后，可能更划算在内部处理交易。

你还需要考虑依赖第三方的工程成本：你的团队将不得不学习如何使用供应商的 API，并且你可能需要按照供应商的时间表跟踪 API 的更改/发布。

#### 可靠性风险

通过外包支付处理，你为你的应用程序增加了一个额外的依赖关系 - 在这种情况下，是第三方服务。额外的依赖通常会引入额外的故障模式。在第三方依赖的情况下，这些故障模式可能部分地超出你的控制。例如，如果支付提供商的服务停机或通过网络无法访问，你的用户故事“用户可以购买他们选择的小部件”可能会失败。这种风险的重要性取决于你与该提供商的[SLAs](https://oreil.ly/KZ03g)的遵守程度。

你可以通过在系统中引入冗余来解决这个风险（参见第八章） - 在这种情况下，通过添加备用支付提供商，你的服务可以切换到备用支付提供商。这种冗余引入了成本和复杂性 - 两个支付提供商很可能有不同的 API，因此你必须设计你的系统能够与两者通信，以及所有额外的工程和运营成本，以及增加对错误或安全妥协的暴露。

你也可以通过你自己的后备机制来减轻可靠性风险。例如，如果支付服务不可达，你可以在通信渠道与支付提供商中插入一个队列机制来缓冲交易数据。这样做将允许“购买流程”用户故事在支付服务中断期间继续进行。

然而，添加消息队列机制会引入额外的复杂性，并可能引入自己的故障模式。如果消息队列没有设计成可靠的（例如，它只在易失性内存中存储数据），你可能会丢失交易 - 这是一个新的风险。更一般地说，只在罕见和特殊情况下使用的子系统可能隐藏着隐藏的错误和可靠性问题。

你可以选择使用更可靠的消息队列实现。这可能涉及分布在多个物理位置的内存存储系统，再次引入复杂性，或者存储在持久性磁盘上。即使只在特殊情况下将数据存储在磁盘上，也会重新引入关于存储敏感数据（妥协风险、合规考虑等）的担忧，这正是你一开始想要避免的。特别是，一些支付数据甚至不允许命中磁盘，这使得依赖持久存储的重试队列难以应用在这种情况下。

在这种情况下，你可能需要考虑攻击（特别是内部人员的攻击），他们有意打破与支付提供商的联系，以激活交易数据的本地排队，然后可能被 compromise。

总之，你最终会遇到一个安全风险，这是由于你试图减轻可靠性风险而产生的，而这又是因为你试图减轻安全风险！

#### 安全风险

依赖第三方服务的设计选择也立即引起了安全考虑。

首先，你正在把敏感的客户数据交给第三方供应商。你需要选择一个安全立场至少与你自己相等的供应商，并且必须在选择和持续评估供应商时进行仔细评估。这不是一项容易的任务，还有复杂的合同、监管和责任考虑因素，这些都超出了本书的范围，应该咨询你的法律顾问。

其次，与供应商服务集成可能需要您将供应商提供的库链接到您的应用程序中。这会带来一个风险，即该库中的漏洞，或者其传递依赖关系中的一个漏洞，可能导致*您*系统中的漏洞。您可以考虑通过对该库进行沙盒化⁵并准备快速部署更新版本来减轻这种风险（参见第七章）。您可以通过使用不需要您将专有库链接到您的服务中的供应商（参见第六章）来基本避免这种担忧。如果供应商使用像 REST+JSON、XML、SOAP 或 gRPC 这样的开放协议来公开其 API，那么可以避免使用专有库。

您可能需要在您的 Web 应用程序客户端中包含一个 JavaScript 库，以便与供应商集成。这样做可以避免通过您的系统传递付款数据，即使是暂时的——相反，付款数据可以直接从用户的浏览器发送到提供商的 Web 服务。然而，这种集成引发了与包含服务器端库类似的担忧：供应商的库代码在您应用程序的 Web 来源中以完全权限运行。⁶该代码的漏洞或者提供该库的服务器的妥协可能导致您的应用程序受到威胁。您可以考虑通过在单独的 Web 来源或沙箱 iframe 中对与付款相关的功能进行沙盒化来减轻这种风险。然而，这种策略意味着您需要一个安全的跨来源通信机制，这再次引入了复杂性和额外的故障模式。另外，付款供应商可能提供基于 HTTP 重定向的集成，但这可能导致用户体验不够流畅。

与非功能性需求相关的设计选择可能在领域特定技术专业知识领域产生相当深远的影响：我们开始讨论与处理付款数据相关的风险缓解相关的权衡，最终考虑到了深入到 Web 平台安全领域的考虑。在这个过程中，我们还遇到了合同和监管方面的问题。

# 管理紧张关系和调整目标

通过一些前期规划，您通常可以满足重要的非功能性需求，如安全性和可靠性，而无需放弃功能，并且成本合理。当回顾整个系统和开发运营工作流程的背景来考虑安全性和可靠性时，往往会发现这些目标与一般软件质量属性非常一致。

## 示例：微服务和谷歌 Web 应用程序框架

考虑谷歌内部微服务和 Web 应用程序框架的演变。创建该框架的团队的主要目标是简化大型组织的应用程序和服务的开发和运营。在设计这个框架时，团队融入了一个关键的想法，即应用静态和动态的*符合性检查*，以确保应用代码符合各种编码准则和最佳实践。例如，符合性检查验证在并发执行上下文之间传递的所有值都是不可变类型——这种做法极大地降低了并发错误的可能性。另一组符合性检查强制执行组件之间的隔离约束，这样就不太可能导致应用程序中一个组件的更改导致另一个组件中的错误。

因为基于这个框架构建的应用程序具有相当严格和明确定义的结构，所以该框架可以为许多常见的开发和部署任务提供开箱即用的自动化功能——从新组件的脚手架搭建，到持续集成（CI）环境的自动设置，再到大部分自动化的生产部署。这些优势使得这个框架在谷歌开发人员中非常受欢迎。

所有这些与安全性和可靠性有什么关系？该框架开发团队在设计和实现阶段与 SRE 和安全团队合作，确保安全性和可靠性最佳实践被编织到框架的结构中，而不是在最后才添加。该框架负责处理许多常见的安全性和可靠性问题。同样，它还自动设置了操作指标的监控，并整合了可靠性功能，如健康检查和 SLA 合规性。

例如，该框架的 Web 应用程序支持处理了大多数常见类型的 Web 应用程序漏洞。通过 API 设计和代码符合性检查的结合，它有效地防止开发人员在应用程序代码中意外引入许多常见类型的漏洞。就这些类型的漏洞而言，该框架不仅仅是“默认安全性”，而是全面负责安全，并积极确保基于它的任何应用程序不受这些风险的影响。我们将在第六章和第十二章中更详细地讨论这是如何实现的。

## 对新出现的属性要求进行对齐

该框架示例说明，与常见看法相反，与其他产品目标（尤其是代码和项目健康、可维护性和长期持续的项目速度）相关的安全性和可靠性目标通常是很好对齐的。相比之下，试图作为后期附加的方式来追加安全性和可靠性目标通常会导致增加风险和成本。

安全性和可靠性的优先级也可以与其他领域的优先级对齐：

+   正如在第六章中讨论的那样，使人们能够有效和准确地推理系统的不变量和行为对于安全性和可靠性至关重要。可理解性也是代码和项目健康属性的关键，也是开发速度的关键支持：一个可理解的系统更容易调试和修改（而不会在一开始引入错误）。

+   设计用于恢复（见第九章）使我们能够量化和控制由变更和部署引入的风险。通常，这里讨论的设计原则支持更高的变更速度（即部署速度），这是我们以其他方式无法实现的。

+   安全性和可靠性要求我们设计一个不断变化的环境（见第七章）。这样做使我们的系统设计更具适应性，不仅能迅速应对新出现的漏洞和攻击场景，还能更快地适应不断变化的业务需求。

# 初始速度与持续速度

特别是在较小的团队中，有一种自然倾向，即将安全性和可靠性问题推迟到将来的某个时间点（“等我们有了一些客户后，我们会加入安全性并担心扩展问题”）。团队通常会以“速度”为借口，忽视安全性和可靠性作为早期和主要的设计驱动因素，他们担心花时间思考和解决这些问题会减慢开发速度，并在首次发布周期中引入不可接受的延迟。

重要的是要区分初始速度和持续速度。选择不考虑安全、可靠性和可维护性等关键要求可能确实会增加项目在项目生命周期早期的速度。然而，经验表明，这样做通常也会在项目后期显著减速。在项目周期后期进行大规模修改以满足作为新兴属性出现的要求的成本可能非常高。此外，为了解决安全和可靠性风险而进行侵入性的后期更改本身可能会引入更多的安全和可靠性风险。因此，早期将安全和可靠性融入团队文化非常重要。

互联网的早期历史和 IP、TCP、DNS 和 BGP 等基础协议的设计和演变，为这个话题提供了有趣的视角。可靠性——特别是在节点故障的情况下网络的生存能力以及在容易出现故障的链路上通信的可靠性——是早期互联网的早期前身，如 ARPANET 的明确和高优先级的设计目标。

然而，在早期的互联网论文和文档中并没有多少提到安全。早期的网络基本上是封闭的，由受信任的研究和政府机构操作节点。但在今天的开放互联网中，这种假设根本不成立——许多类型的恶意行为者参与了网络。

互联网的基础协议——IP、UDP 和 TCP——没有规定对传输发起者进行身份验证，也没有检测网络中间节点对数据的故意恶意修改。许多更高级的协议，如 HTTP 或 DNS，天生就容易受到网络中恶意参与者的各种攻击。随着时间的推移，已经开发了安全协议或协议扩展来抵御此类攻击。例如，HTTPS 通过在经过身份验证的安全通道上传输数据来增强 HTTP。在 IP 层，IPsec 通过加密对网络级对等体进行身份验证，并提供数据完整性和保密性。IPsec 可用于在不受信任的 IP 网络上建立 VPN。

然而，广泛部署这些安全协议已被证明相当困难。我们现在大约已经进入互联网历史的第 50 年，互联网的重要商业用途可能始于 25 或 30 年前，但仍有相当大比例的网络流量不使用 HTTPS。

另一个关于初始和持续速度之间权衡的例子（在这种情况下来自安全和可靠性领域之外），请考虑敏捷开发流程。敏捷开发工作流的主要目标是增加开发和部署速度，特别是减少功能规范和部署之间的延迟。然而，敏捷工作流通常依赖于相当成熟的单元和集成测试实践以及稳固的持续集成基础设施，这需要前期投资来建立，以换取长期的速度和稳定性。

更一般地，您可以选择将初始项目速度置于一切之上——您可以开发 Web 应用的第一个迭代而不进行测试，并且发布过程相当于将 tarballs 复制到生产主机。您可能会相对快速地完成第一个演示，但到第三个发布时，您的项目很可能会拖后腿，并且负担着技术债务。

我们已经提到了可靠性和速度之间的一致性：投资于成熟的持续集成/持续部署（CI/CD）工作流和基础设施支持频繁的生产发布，同时管理和接受可靠性风险（参见第七章）。但是设置这样的工作流需要一些前期投资——例如，你将需要以下内容：

+   足够健壮的单元和集成测试覆盖率，以确保生产发布的缺陷风险可接受，而不需要进行主要的人工发布资格工作

+   本身可靠的 CI/CD 流水线

+   经常使用的、可靠的基础设施，用于分阶段的生产发布和回滚

+   允许代码和配置的[解耦部署](https://oreil.ly/8E04K)的软件架构（例如，“功能标志”）

这种投资在产品生命周期的早期进行时通常是适度的，而且只需要开发人员持续付出一些增量努力来保持良好的测试覆盖率和持续构建的“绿色”。相比之下，具有较差的测试自动化、依赖于部署中的手动步骤和长周期发布的开发工作流往往会在项目变得复杂时最终拖慢项目的速度。在那时，为成熟系统添加测试和发布自动化往往需要一次性进行大量工作，可能会进一步减慢项目的速度。此外，为成熟系统添加的测试有时会陷入陷阱，更多地测试当前存在的错误行为而不是正确的预期行为。

这些投资对各种规模的项目都是有益的。然而，较大的组织可以享受更多规模效益，因为你可以将成本分摊到许多项目中——一个单独项目的投资最终归结为承诺使用集中维护的框架和工作流程。

在做出专注于安全的设计选择以促进持续速度时，我们建议选择一个框架和工作流，提供针对相关漏洞类别的构造安全防御。这种选择可以大大减少甚至消除在应用程序代码库的持续开发和维护过程中引入此类漏洞的风险（参见第[6 章](ch06.html#design_for_understandability)和[12 章](ch12.html#writing_code)）。这种承诺通常不需要重大的前期投资——相反，它需要持续的、通常是适度的努力来遵守框架的约束。作为回报，你大大降低了系统意外停机或安全响应火灾演习对部署计划造成混乱的风险。此外，你的发布时安全性和生产准备审查更有可能顺利进行。

# 结论

设计和构建安全可靠的系统并不容易，特别是因为安全性和可靠性主要是整个开发和运营工作流的新兴属性。这项工作涉及思考许多相当复杂的主题，其中许多起初似乎与解决服务的主要功能要求并不那么相关。

你的设计过程将涉及安全性、可靠性和功能要求之间的许多权衡。在许多情况下，这些权衡起初似乎是直接冲突的。在项目的早期阶段避开这些问题可能会很诱人，然后“以后再处理”——但这样做往往会对项目造成重大的成本和风险：一旦你的服务上线，可靠性和安全性就不是可选的。如果你的服务中断，你可能会失去业务；如果你的服务受到损害，应对将需要全员出动。但通过良好的规划和谨慎的设计，通常可以满足这三个方面。更重要的是，你可以在较少的额外前期成本和通常减少系统寿命内的总工程工作量的情况下做到这一点。

¹ For a more formal treatment, see [The MITRE Systems Engineering Guide](https://oreil.ly/ful41) and [ISO/IEC/IEEE 29148-2018(E)](https://oreil.ly/GD6cY).

² For the purposes of the example, it’s not relevant what exactly is being sold—a media outlet might require payments for articles, a mobility company might require payments for transportation, an online marketplace might enable the purchase of physical goods that are shipped to consumers, or a food-ordering service might facilitate the delivery of takeout orders from local restaurants.

³ See, for example, McCallister, Erika, Tim Grance, and Karen Scarfone. 2010\. NIST Special Publication 800-122, “Guide to Protecting the Confidentiality of Personally Identifiable Information (PII).” [*https://oreil.ly/T9G4D*](https://oreil.ly/T9G4D).

⁴ Note that whether or not this is appropriate may depend on regulatory frameworks your organization is subject to; these regulatory matters are outside the scope of this book.

⁵ See, e.g., the [Sandboxed API](https://oreil.ly/fx86y) project.

⁶ For more on this subject, see Zalewski, Michał. 2011\. *The Tangled Web: A Guide to Securing Modern Web Applications*. San Francisco, CA: No Starch Press.

⁷ See, e.g., the [OWASP Top 10](https://oreil.ly/O0kva) and [CWE/SANS TOP 25 Most Dangerous Software Errors](https://oreil.ly/Fm6IJ).

⁸ See Kern, Christoph. 2014\. “Securing the Tangled Web.” *Communications of the ACM* 57(9): 38–47\. doi:10.1145/2643134.

⁹ At Google, software is typically built from the HEAD of a common repository, which causes all dependencies to be updated automatically with every build. See Potvin, Rachel, and Josh Levenberg. 2016\. “Why Google Stores Billions of Lines of Code in a Single Repository.” *Communications of the ACM* 59(7): 78–87\. [*https://oreil.ly/jXTZM*](https://oreil.ly/jXTZM).

¹⁰ See the discussion of tactical programming versus strategic programming in Ousterhout, John. 2018\. *A Philosophy of Software Design*. Palo Alto, CA: Yaknyam Press. [Martin Fowler](https://oreil.ly/Lc2eY) makes similar observations.

¹¹ See [RFC 2235](https://oreil.ly/UIlV6) and Leiner, Barry M. et al. 2009\. “A Brief History of the Internet.” *ACM SIGCOMM Computer Communication Review* 39(5): 22–31\. doi:10.1145/1629607.1629613.

¹² Baran, Paul. 1964\. “On Distributed Communications Networks.” *IEEE Transactions on Communications Systems* 12(1): 1–9\. doi:10.1109/TCOM.1964.1088883.

¹³ Roberts, Lawrence G., and Barry D. Wessler. 1970\. “Computer Network Development to Achieve Resource Sharing.” *Proceedings of the 1970 Spring Joint Computing Conference*: 543–549\. doi:10.1145/1476936.1477020.

¹⁴ 费尔特，阿德里安·波特，理查德·巴恩斯，艾普里尔·金，克里斯·帕尔默，克里斯·本策尔和帕里萨·塔布里兹。2017 年。 “测量网络上的 HTTPS 采用情况。” *第 26 届 USENIX 安全研讨会论文集*：1323–1338。[*https://oreil.ly/G1A9q*](https://oreil.ly/G1A9q)。
