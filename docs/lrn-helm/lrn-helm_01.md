# 第一章：介绍 Helm

Helm 是 Kubernetes 的包管理器。这是 Helm 开发者自 Git 仓库的第一次提交以来就一直在描述的方式。而这句话也是本章的主题。

在本章中，我们将从概念上看云原生生态系统，其中 Kubernetes 是一个关键技术。我们将重新审视 Kubernetes 提供的功能，为描述 Helm 做好准备。

接下来，我们将探讨 Helm 旨在解决的问题。在本节中，我们将看看包管理的概念以及为什么我们模仿 Helm 的方式进行建模。我们还将探讨将软件包安装到像 Kubernetes 这样的集群管理工具中的一些独特方面。

最后，我们将通过高层次的方式来看 Helm 的架构，重点介绍图表、模板和发布的概念。通过本章的学习，你将理解 Helm 如何融入到更广泛的工具生态系统中，你将熟悉本书中将要使用的术语和概念。

# 云原生生态系统

云技术的出现显然改变了行业对硬件、系统管理、物理网络等的看法。虚拟机取代了物理服务器，存储服务取代了硬盘的讨论，自动化工具日益突出。这或许是行业在概念化云时的早期变化。但随着这种新方法的优劣逐渐清晰，设计应用程序和服务的实践也开始转变。

开发者和运维人员开始质疑构建大型单一二进制应用程序的实践，这些应用程序在强大的硬件上执行。他们意识到在不同应用程序之间共享数据并保持数据完整性的困难。分布式锁定、存储和缓存成为主流问题，而不是学术兴趣点。大型软件包被分解为更小的离散可执行文件。正如 Kubernetes 的创始人 Brendan Burns 经常所说，“分布式计算从高级话题变成了计算机科学 101。”

“云原生”这一术语捕捉到了我们对云架构视角的这种认知转变。当我们围绕云的能力和约束设计我们的系统时，我们正在设计云原生系统。

## 容器和微服务

云原生计算的核心理念是：*更倾向于小型独立的单一服务*，而不是做一切的*大型单体服务*。不再编写一个处理从生成用户界面到处理任务队列再到与数据库和缓存交互的单一大型应用程序。云原生的方法是编写一系列较小、相对特定目的的服务，然后将这些服务组合在一起以实现更高层次的目的。在这种模型中，一个服务可能是关系数据库的唯一用户。希望访问数据的服务将通过（通常是）表述状态转移（REST）API 联系该服务。然后，这些其他服务将使用基于 JavaScript 对象表示法（JSON）的 HTTP 查询和更新数据。

这种分解允许开发人员隐藏低级实现，而是提供一组特定于更广泛应用程序业务逻辑的功能。

### 微服务

曾经，一个应用程序由一个执行所有工作的单个可执行程序组成，云原生应用程序是*分布式应用程序*。虽然单独的程序分别负责一个或两个离散任务，但这些程序共同形成一个单一的逻辑应用程序。

有了所有这些理论，一个简单的例子可能更好地解释这是如何工作的。想象一个电子商务网站。我们可以认为一起组成这种网站的几个任务。有产品目录，用户账户和购物车，处理货币交易安全过程的支付处理器，以及顾客查看商品并选择购买的前端。还有一个管理界面，店主在其中管理库存和完成订单。

历史上，这样的应用程序曾经被构建为一个单一的程序。负责每个工作单元的代码都被编译到一个大型可执行文件中，然后通常在单个大型硬件上运行。

但是，云原生方法是将这个电子商务应用程序分解为多个部分。一个处理支付交易。另一个跟踪产品目录。再一个提供管理界面，等等。然后，这些服务通过网络使用明确定义的 REST API 彼此通信。

将应用程序分解为最小的组成部分，并且每个部分都是一个程序，这是*微服务架构*的极端情况。微服务站在单体应用程序的相反极端，负责处理整体应用程序处理的一个小部分。

微服务概念对云原生计算的演变产生了巨大影响。在*容器计算*的出现中，这一点表现得尤为明显。

### 容器

将容器与虚拟机进行比较和对比是很常见的。虚拟机在主机机器上的隔离环境中运行整个操作系统。相比之下，容器有自己的文件系统，但在主机的操作系统内核中执行。

但是有一种第二种概念化容器的方式——这种方式可能对当前的讨论更有益。正如其名称所示，*容器*提供了一种有用的方式，可以将单个程序的运行时环境打包起来，以便在将其从一个主机移动到另一个主机时，可以保证可执行文件的所有依赖项都得到满足。

这是一种更为哲学的方法，也许是因为它对容器施加了一些非技术性的限制。例如，一个容器可以打包十几个不同的程序，并同时执行它们。但是容器，至少按照 Docker 的设计初衷，是作为一个顶层程序的载体。

###### 注意

当我们在这里讨论程序时，我们实际上在思考比“一个二进制文件”更高层次的抽象。大多数 Docker 容器至少有几个可执行文件，它们只是为了辅助主程序存在。但这些可执行文件是辅助于容器的主要功能的。例如，一个 Web 服务器可能需要一些其他本地实用工具来启动或执行低级任务（例如 Apache 有模块工具），但主要程序还是 Web 服务器本身。

容器和微服务从设计上来说是完美匹配的。小型独立程序可以打包，以及它们所有的依赖项，进入修长的容器中。并且这些容器可以从一个主机移动到另一个主机。在执行容器时，主机无需拥有执行程序所需的所有工具，因为所有这些工具都打包在容器内。主机只需要能够运行容器。

例如，如果一个程序是在 Python 3 中构建的，主机不需要安装 Python，配置它，然后安装程序所需的所有库。所有这些都打包在容器中。当主机执行容器时，正确版本的 Python 3 和每个所需的库已经存储在容器中。

进一步说，主机可以自由地执行具有竞争需求的容器。一个容器化的 Python 2 程序可以在与容器化的 Python 3 需求相同的主机上运行，主机管理员无需进行任何特殊工作来配置这些竞争需求！

这些例子说明了云原生生态系统的一个特性：管理员、运维人员和可靠性工程师（SREs）不再负责管理程序依赖关系。相反，他们可以自由地专注于更高级别的资源分配。运维人员不再为不同服务器上运行的 Python、Ruby 和 Node 的版本而烦恼，而是可以专注于网络、存储和 CPU 资源是否正确分配给这些容器化工作负载。

有时在完全隔离的环境中运行程序是有用的。但更常见的情况是，我们希望将容器的某些方面暴露给外部世界。我们希望它可以访问存储。我们希望允许它响应网络连接。我们希望根据我们目前的需求向容器中注入一些配置小贴士。所有这些任务（还有更多任务）由容器运行时提供。当容器声明其具有一个在端口 8080 上内部侦听的服务时，容器运行时可能会在主机端口 8000 上授予其访问权限。因此，当主机在端口 8000 上收到网络请求时，容器将其视为对其端口 8080 的请求。同样，主机可以将文件系统挂载到容器中，或在容器内设置特定的环境变量。通过这种方式，容器可以参与其周围更广泛的环境——包括不仅限于同一主机上的其他容器，还包括本地网络甚至互联网上的远程服务。

### 容器镜像和注册表

容器技术本身就是一个复杂而引人入胜的领域。但就我们的目的而言，在我们继续到云原生堆栈的下一层之前，我们只需要理解一些关于容器如何工作的更多信息。

正如我们在前一节中讨论的那样，容器是一个程序及其依赖项和环境的整体。这整个内容可以打包成一个称为*容器镜像*（通常简称为*镜像*）的可移植表示。镜像不是打包成一个大型二进制文件；而是打包成离散的*层*，每个层都有其自己的唯一标识符。当镜像被移动时，它们作为一组层移动，这提供了巨大的优势。如果一个主机有一个包含五层的镜像，而另一个主机需要相同的镜像，它只需获取它尚未具备的层。因此，如果它已经有了五层中的两层，它只需获取三层即可重建整个容器。

有一个关键的技术组件提供了移动容器镜像的能力。*镜像注册表*是一种专门的存储技术，用于存储容器，使它们对主机可用。主机可以将容器镜像*推送*到注册表，将层传输到注册表。然后另一个主机可以从注册表*拉取*镜像到主机的环境中，之后主机可以执行容器。

注册表管理这些层。当一个主机请求一个镜像时，注册表会告诉主机组成该镜像的哪些层。然后主机可以确定缺少的层（如果有的话），并从注册表中仅下载那些层。

注册表使用最多三个信息来标识特定的镜像：

名称

一个镜像的*名称*可以是简单的也可以是复杂的，这取决于存储镜像的注册表：`nginx`，`servers/nginx`，或者 `example.com/servers/nginx`。

标签

*标签*通常指安装的软件版本（`v1.2.3`），尽管标签实际上只是任意的字符串。标签 `latest` 和 `stable` 通常用于表示“最新版本”和“最新的生产就绪版本”，分别。

摘要

有时候拉取一个非常特定版本的镜像很重要。由于标签是*可变的*，不能保证在任何给定时间标签指向*确切*的软件版本。因此，注册表支持通过*摘要*来获取镜像，这是镜像层信息的 SHA-256 或 SHA-512 摘要。

在本书中，我们将看到使用前述三个信息引用的镜像。组合这些信息的规范格式是 `name:tag@digest`，其中只有 `name` 是必需的。因此，`example.com/servers/nginx:latest` 表示“给我命名为 `example.com/servers/nginx` 的镜像的标签 `latest`。”以及

```
example.com/my/app@sha256:
a428de44a9059feee59237a5881c2d2cffa93757d99026156e4ea544577ab7f3
```

告诉“给我`example.com/my/app`，并提供此处的确切摘要。”

虽然关于镜像和容器还有很多要学习的内容，但我们现在已经有足够的知识来继续下一个重要的主题：调度器。在那一部分，我们将了解 Kubernetes。

## 计划和 Kubernetes

在前一节中，我们看到容器封装了单独的程序及其所需的环境。容器可以在工作站上本地执行，也可以在服务器上远程执行。

随着开发人员开始将他们的应用程序打包成容器，并且操作人员开始使用容器作为部署的工件，出现了一系列新的问题。我们如何最好地执行大量容器？我们如何最好地支持需要共同工作的大量容器的微服务架构？我们如何明智地共享对像网络附加存储、负载均衡器和网关等的访问？我们如何管理向大量容器注入配置信息？也许最重要的是，我们如何管理内存、CPU、网络带宽和存储空间等资源？

更进一步，人们开始询问（基于他们对虚拟机的经验），如何在多个主机上管理分布式容器，如何在保证资源的合理使用的同时均匀分布负载？或者更简单地说，我们如何在运行尽可能少的主机的同时运行我们需要的尽可能多的容器？

2015 年，时机成熟：Docker 容器正在企业中取得进展。并且有一个明显的需求，即需要一种工具来管理跨主机的容器调度和资源管理。多种技术进入市场：Mesos 推出了 Marathon；Docker 创建了 Swarm；Hashicorp 发布了 Nomad；Google 则为其内部 Borg 平台创建了一个开源版本，并将此技术命名为 Kubernetes（希腊语中船长的意思）。

所有这些项目都提供了一个集群化容器管理系统的实现，可以调度容器并为托管复杂的微服务式分布式应用程序连接它们。

每个调度器都有其优点和缺点。但是 Kubernetes 引入了两个概念使其脱颖而出：*声明性基础设施* 和 *协调循环*。

### 声明性基础设施

考虑部署容器的情况。一个人可能会以如下方式处理部署容器的过程：我创建容器。我打开一个端口让它监听，并在文件系统的特定位置上附加一些存储。然后我等待所有初始化完成。然后我测试它以查看容器是否准备就绪。然后我标记它为可用。

在这种方法中，我们通过专注于设置容器的过程来*过程化*思考。但 Kubernetes 的设计是我们*声明式*地思考。我们告诉调度器（Kubernetes）我们的期望状态是什么，Kubernetes 负责将该声明转换为其内部的操作流程。

在 Kubernetes 上安装容器更像是说：“我希望这个容器在这个端口上运行，使用这么多的 CPU 并且在文件系统的这个位置上挂载一些存储。” Kubernetes 在幕后工作，根据我们声明的需求连接所有内容。

### 协调循环

Kubernetes 如何在幕后处理所有这些？当我们从过程的角度来看待事物时，那里有一定的操作顺序。Kubernetes 如何知道顺序？这就是 *协调循环* 的概念发挥作用的地方。

在协调循环中，调度器会说：“这是用户的期望状态。这是当前的状态。它们不同，所以我将采取步骤来调和它们。” 用户需要容器的存储。目前没有附加存储。因此 Kubernetes 创建了一个存储单元并将其附加到容器上。容器需要一个公共网络地址。目前不存在。因此将一个新的地址附加到容器上。Kubernetes 中的不同子系统会努力履行其用户期望状态的各个部分。

最终，Kubernetes 将会成功创建用户期望的环境，或者得出无法实现用户愿望的结论。与此同时，用户在观察 Kubernetes 集群并等待其成功或标记安装失败时扮演被动角色。

### 从容器到 pod、服务、部署等等。

虽然简洁，但上面的示例有些误导性。Kubernetes 并不一定把容器作为工作的单元。相反，Kubernetes 引入了一个更高级的抽象称为 *pod*。一个 pod 是一个抽象的信封，描述了一个独立的工作单元。一个 pod 描述的不仅仅是一个容器，还包括一个或多个容器（以及它们的配置和需求），这些容器一起执行一个工作单元：

```
apiVersion: v1 ![1](img/1.png)
kind: Pod
metadata:
    name: example-pod
spec:
    containers: ![2](img/2.png)
    - image: "nginx:latest"
      name: example-nginx
```

![1](img/#co_introducing_helm_CO1-1)

前两行定义了 Kubernetes 类型（v1 Pod）。

![2](img/#co_introducing_helm_CO1-2)

一个 pod 可以有一个或多个容器。

大多数情况下，一个 pod 只有一个容器。但有时它们会有一些在主容器上线之前进行一些预配置的容器，然后退出。这些被称为 *init containers*。另外有时候还有运行在主容器旁边并提供辅助服务的容器。这些被称为 *sidecar containers*。它们都被视为同一个 pod 的一部分。

###### 注意

在前面的代码中，我们编写了一个 Kubernetes `Pod` 资源的定义。当这些定义表达为 YAML 或 JSON 时，被称为 *manifests*。一个 manifest 可以包含一个或多个 Kubernetes *资源*（也称为 *对象* 或 *资源定义*）。每个资源与 Kubernetes 的一个 *类型* 相关联，比如 `Pod` 或 `Deployment`。在本书中，我们通常使用 *资源*，因为 *对象* 这个词被重载了：YAML 将 *对象* 定义为一个命名的键/值结构。

`Pod` 描述了容器或容器需要的配置（如网络端口或文件系统挂载点）。在 Kubernetes 中，配置信息可以存储在 *ConfigMaps* 中，对于敏感信息，可以存储在 *Secrets* 中。`Pod` 的定义可能会将这些 `ConfigMap` 和 `Secret` 关联到每个容器内的环境变量或文件中。当 Kubernetes 看到这些关系时，它将尝试按照 `Pod` 的定义附加和配置配置数据：

```
apiVersion: v1 ![1](img/1.png)
kind: ConfigMap
metadata:
    name: configuration-data
data: ![2](img/2.png)
    backgroundColor: blue
    title: Learning Helm
```

![1](img/#co_introducing_helm_CO2-1)

在这种情况下，我们声明了一个 `v1 ConfigMap` 对象。

![2](img/#co_introducing_helm_CO2-2)

在 `data` 内部，我们声明了一些任意的名称/值对。

`Secret` 在结构上类似于 `ConfigMap`，不同之处在于 `data` 部分的值必须进行 Base64 编码。

`Pod` 通过 *volumes* 与配置对象（如 `ConfigMap` 或 `Secret`）关联。在本例中，我们采用了上面的 `Pod` 示例，并附加了上述 `Secret`：

```
apiVersion: v1
kind: Pod
metadata:
    name: example-pod
spec:
    volumes: ![1](img/1.png)
    - name: my-configuration
      configMap:
        name: configuration-data ![2](img/2.png)
    containers:
    - image: "nginx:latest"
      name: example-nginx
      env: ![3](img/3.png)
        - name: BACKGROUND_COLOR ![4](img/4.png)
          valueFrom:
            configMapKeyRef:
                name: configuration-data ![5](img/5.png)
                key: backgroundColor ![6](img/6.png)
```

![1](img/#co_introducing_helm_CO3-1)

`volumes`部分告诉 Kubernetes 此 Pod 需要哪些存储源。

![2](img/#co_introducing_helm_CO3-2)

名称`configuration-data`是我们在前面示例中创建的`ConfigMap`的名称。

![3](img/#co_introducing_helm_CO3-3)

`env`部分将环境变量注入到容器中。

![4](img/#co_introducing_helm_CO3-4)

环境变量在容器内将被命名为`BACKGROUND_COLOR`。

![5](img/#co_introducing_helm_CO3-5)

这是它将使用的`ConfigMap`的名称。如果我们希望将其作为文件系统卷使用，此映射必须在`volumes`中。

![6](img/#co_introducing_helm_CO3-6)

这是`ConfigMap`的`data`部分内键的名称。

一个`Pod`是可运行工作单元的“原始”描述，其中包含容器。但是 Kubernetes 引入了更高级别的概念。

考虑一个 Web 应用程序。我们可能不希望只运行一个此 Web 应用程序的实例。如果我们只运行一个实例，如果它失败了，我们的站点将会宕机。如果我们想升级它，我们将不得不想办法在不关闭整个站点的情况下进行升级。因此，Kubernetes 引入了*Deployment*的概念。`Deployment`描述了一个应用程序作为一组相同的`Pod`。`Deployment`由一些顶层配置数据组成，以及用于构建副本`Pod`的模板。

使用`Deployment`，我们可以告诉 Kubernetes 创建我们的应用程序一个单独的`Pod`。然后我们可以将其扩展到五个`Pod`，再缩减到三个`Pod`。我们可以附加*HorizontalPodAutoscaler*（另一种 Kubernetes 类型），并配置它根据资源使用情况扩展我们的`Pod`。当我们升级应用程序时，`Deployment`可以采用各种策略逐步升级单个`Pod`，而不会导致整个应用程序宕机：

```
apiVersion: apps/v1 ![1](img/1.png)
kind: Deployment
metadata:
    name: example-deployment
    labels:
        app: my-deployment
spec:
    replicas: 3 ![2](img/2.png)
    selector:
        matchLabels:
            app: my-deployment
    template: ![3](img/3.png)
        metadata:
            labels:
                app: my-deployment
        spec:
            containers:
            - image: "nginx:latest"
              name: example-nginx
```

![1](img/#co_introducing_helm_CO4-1)

这是一个`apps/v1 Deployment`对象。

![2](img/#co_introducing_helm_CO4-2)

在规范内部，我们要求三个副本的以下`template`。

![3](img/#co_introducing_helm_CO4-3)

模板指定每个副本`Pod`的外观应该如何。

当涉及将 Kubernetes 应用程序附加到网络上的其他内容时，Kubernetes 提供了*Service*定义。`Service`是一种持久的网络资源（类似于静态 IP），即使与其连接的`Pod`或`Pods`消失，它也会持续存在。这样，Kubernetes `Pod`可以来去自如，而网络层仍然可以继续将流量路由到相同的`Service`端点。虽然`Service`是一个抽象的 Kubernetes 概念，但在幕后它可以被实现为从路由规则到外部负载均衡器的任何内容：

```
apiVersion: v1 ![1](img/1.png)
kind: Service
metadata:
  name: example-service
spec:
  selector:
    app: my-deployment ![2](img/2.png)
  ports:
    - protocol: TCP ![3](img/3.png)
      port: 80
      targetPort: 8080
```

![1](img/#co_introducing_helm_CO5-1)

类型是`v1 Service`。

![2](img/#co_introducing_helm_CO5-2)

这个`Service`将路由到具有`app: my-deployment`标签的`Pod`。

![3](img/#co_introducing_helm_CO5-3)

TCP 流量到这个 `Service` 的 `80` 端口将路由到与 `app: my-deployment` 标签匹配的 pods 的 `8080` 端口。

所描述的 `Service` 将流量路由到我们之前创建的 `Deployment`。

我们已经介绍了许多 Kubernetes 类型中的一些。还有很多我们可以覆盖的类型，但迄今为止使用最频繁的类型是 `Pod`, `Deployment`, `ConfigMap`, `Secret` 和 `Service`。在下一章中，我们将更直接地开始使用这些概念。但是现在，凭借一些通用信息，我们可以介绍 Helm。

# Helm 目标

到目前为止，我们专注于更广泛的云原生生态系统及其在其中的角色。在本节中，我们将把焦点转向 Helm。

在前一节中，我们看到了几个不同的 Kubernetes 资源：一个 `Pod`，一个 `ConfigMap`，一个 `Deployment` 和一个 `Service`。每一个资源都扮演着不同的角色。但是一个 *应用程序* 通常需要其中多个。

例如，WordPress CMS 系统可以在 Kubernetes 内部运行。但通常需要至少一个 `Deployment`（用于 WordPress 服务器），一个 `ConfigMap` 用于配置，可能还需要一个 `Secret`（用于保存密码），几个 `Service` 对象，一个运行数据库的 `StatefulSet`，以及几个基于角色的访问控制（RBAC）规则。已经，一个基本的 WordPress 站点的 Kubernetes 描述将涵盖数千行 YAML。Helm 的核心理念之一是，所有这些对象可以打包在一起进行安装、更新和删除。

当我们编写 Helm 时，我们有三个主要目标：

1.  让从“零到 Kubernetes”变得更容易

1.  提供像操作系统那样的软件包管理系统

1.  强调安全性和可配置性，用于部署应用到 Kubernetes

我们将审视这三个目标，并看看 Helm 在生命周期管理故事中的参与情况。

## 从零到 Kubernetes

Helm 项目始于 2015 年，比首届 KubeCon 会议早几个月。设置 Kubernetes 很困难，通常需要新用户编译 Kubernetes 源代码，然后使用一些 shell 脚本来运行 Kubernetes。一旦集群启动，新用户就被期望从头开始编写 YAML（正如我们在之前的章节中所做的）。基本示例很少，没有生产就绪的示例。

我们希望颠覆学习周期：不再要求用户从基本示例开始构建他们自己的应用程序，而是提供用户现成的生产就绪示例。用户可以安装这些示例，看到它们运行，然后学习 Kubernetes 如何工作。

这就是，直到今天，我们与 Helm 的首要任务：使其更容易与 Kubernetes 配合使用。在我们看来，一个新的 Helm 用户在现有的 Kubernetes 集群上应该能够在下载到安装应用程序不到五分钟内完成。

但 Helm 不仅仅是一个学习工具。它是一个软件包管理器。

## 软件包管理

Kubernetes 就像一个操作系统。在其基础上，操作系统为执行程序提供了环境。它提供了存储、执行和监视程序生命周期所需的工具。

它不是执行程序，而是执行容器。但与操作系统类似，它提供了存储、执行和监视这些容器所需的工具。

大多数操作系统都有一个*软件包管理器*。软件包管理器的工作是简化操作系统上程序的查找、安装、升级和删除。软件包管理器提供了打包程序成可安装应用程序的语义，并提供了存储和检索软件包以及安装和管理它们的方案。

当我们将 Kubernetes 视为一个操作系统时，我们很快意识到需要一个 Kubernetes 软件包管理器。从 Helm 源代码库的第一个提交开始，我们始终将软件包管理隐喻应用于 Helm：

+   Helm 提供了包仓库和搜索功能，用于查找可用的 Kubernetes 应用程序。

+   Helm 具有熟悉的安装、升级和删除命令。

+   Helm 定义了一种在安装前配置软件包的方法。

+   此外，Helm 还有工具用于查看已安装的内容及其配置。

最初，我们将 Helm 建模为 Homebrew（macOS 的软件包管理器）和 Apt（Debian 的软件包管理器）。但随着 Helm 的成熟，我们已经努力从尽可能多的不同软件包管理器中学习。

典型操作系统和 Kubernetes 之间存在一些差异。其中之一是，Kubernetes 支持运行多个相同应用程序的实例。而我可能只在工作站上安装 MariaDB 数据库一次，Kubernetes 集群可以运行数十、数百甚至数千个 MariaDB 安装实例，每个实例可能有不同的配置或不同的版本。

另一个在典型操作系统中罕见但在 Kubernetes 中很核心的概念是*命名空间*。在 Kubernetes 中，命名空间是一种任意的分组机制，用于定义命名空间内部和外部的事物之间的边界。有许多不同的方式可以通过命名空间组织资源，但通常它们被用作附着安全性的固定装置。例如，可能只有特定用户可以访问命名空间内的资源。

这些只是 Kubernetes 与传统操作系统不同的几种方式。这些以及其他差异在 Helm 的设计中提出了挑战。我们不得不建立 Helm 以利用这些差异，但又不放弃我们的软件包管理隐喻。

例如，Helm 安装命令不仅需要包的名称，还需要用户提供的名称，用于引用该包的安装版本。在下一章中，我们将看到这方面的例子。

同样，Helm 中的操作是命名空间敏感的。可以将同一个应用程序安装到两个不同的命名空间中，并且 Helm 提供工具来管理这些应用程序的不同实例。

总之，Helm 始终牢固地位于工具包管理类别中。

## 安全性、可重用性和可配置性

Helm 的第三个目标是专注于管理集群中应用程序的三个“必须具备的”功能：

1.  安全性

1.  可重用性

1.  可配置性

简而言之，我们希望 Helm 对这些原则有足够的认识，以便 Helm 用户可以对他们使用的包有信心。用户应能够*验证*一个包来自可信任的来源（且未被篡改），*重复使用*同一个包多次，以及*配置*包以适应他们的需求。

Helm 的开发者可以直接控制前两个设计目标，而这个是独一无二的：Helm 只能为*包作者*提供合适的工具，并希望这些创作者选择实现这三个“必须具备的”目标。

### 安全性

安全性是一个广泛的类别。在这个上下文中，我们指的是当用户检查一个包时，用户有能力验证关于包的某些事项：

+   包来自可信任的来源。

+   拉取包的网络连接是安全的。

+   包没有被篡改。

+   用户可以轻松检查包，以了解其功能。

+   用户可以查看包的配置，以及了解不同的输入如何影响包的输出。

在本书中，特别是在第六章，我们将更详细地讨论安全性。但这五个功能是我们认为 Helm 已经提供的内容。

Helm 提供了*来源*功能，用于建立有关包的来源、作者和完整性的验证。Helm 支持安全套接字层/传输层安全性（SSL/TLS），用于安全地通过网络发送数据。并且 Helm 提供了干预运行、模板和清理命令，以检查包及其可能的排列组合。

### 可重用性

包管理的一个优点是可以重复和可预测地安装相同的内容。稍微扩展一下，使用 Helm，我们甚至可能希望将相同的内容（重复和可预测地）安装到同一个集群或同一个命名空间中。

Helm 图表是可重复使用的关键。一个图表提供了生成相同 Kubernetes 清单的模式。但图表还允许用户提供额外的配置（我们将在下一章讨论）。因此，Helm 提供了存储配置的模式，使得可以重复执行图表加其配置的组合。

这样，Helm 鼓励 Kubernetes 用户将他们的 YAML 打包成图表，以便可以重复使用这些描述。

在 Linux 世界中，每个 Linux 发行版都有自己的包管理器和仓库。而在 Kubernetes 世界中不是这样。Helm 被设计为所有 Kubernetes 发行版可以共享相同的包管理器，以及（极少数例外情况除外）相同的包。当两个不同的 Kubernetes 发行版之间存在差异时，可以使用模板（在第五章中详细讨论）与配置来适应这些差异。

### 可配置性

Helm 提供了将 Helm 图表与一些额外配置结合的模式。例如，我可以使用 Helm 安装一个网站，并在安装时设置该网站的名称。Helm 提供了在安装和升级过程中重新配置包的工具。但需要注意一点。

Helm 是一个包管理器。另一类软件处理*配置管理*。这类软件，以 Puppet、Ansible 和 Chef 为代表，专注于如何为其主机环境*特定配置*的给定软件（通常打包）。其责任是管理随时间变化的配置。

Helm 并非设计成一个配置管理工具，尽管包管理和配置管理之间至少存在一定的重叠。

包管理通常限制于实施三个动作：安装、升级和删除。配置管理则是一个更高层次的概念，专注于长期管理一个或多个应用程序。有时候这被称为“第二天运维”。

虽然 Helm 最初并非旨在成为配置管理工具，但有时会被用作此类工具。组织依赖于 Helm 不仅仅是为了安装、升级和删除，还用于跟踪时间变化、跟踪配置，并确定整个应用程序是否正在运行。Helm 可以在这方面进行扩展，但如果你需要强大的配置管理解决方案，可能需要利用 Helm 生态系统中的其他工具。像 Helmfile、Flux 和 Reckoner 等工具填补了更大配置管理故事中的细节。

###### 注意

Helm 社区创建了大量与 Helm 兼容或增强 Helm 的工具。Helm 项目在[官方文档](https://oreil.ly/hOqca)中维护了这些工具的列表。

你将在 Helm 图表中注意到的一个常见主题是，配置选项经常设置成可以将相同的图表发布到开发环境中的最小版本，或者（通过不同的配置选项）发布到生产环境中的复杂版本。

# Helm 的架构

在本章的最后一节中，我们将简要介绍 Helm 的高级架构。除了完成云原生 Kubernetes 应用程序和软件包管理的概念讨论外，本节还为 第二章 铺平了道路。

## Kubernetes 资源

我们已经查看了几种 Kubernetes 资源类型。我们看到了几个 `Pod` 定义，一个 `ConfigMap`，一个 `Deployment` 和一个 `Service`。Kubernetes 还提供了几十种其他资源类型。您甚至可以使用自定义资源定义（CRD）来定义自己的自定义资源类型。主 Kubernetes 文档提供了关于每种资源类型的可访问指南和详细的 API 文档。

在本书中，我们将使用许多不同的 Kubernetes 资源类型。虽然我们在上下文中讨论它们，但您可能会发现在遇到新的资源定义时，浏览主 Kubernetes 文档是有益的。

正如我们之前讨论的，资源定义是*声明式*的。您作为用户描述了 Kubernetes 所需的资源的期望状态。例如，您可以把我们在本章早些时候创建的 `Pod` 定义理解为一种声明，“我希望 Kubernetes 为我创建一个具有这些特性的 `Pod`”。Kubernetes 将根据您的规范来配置和运行 Pod。

所有 Kubernetes 资源定义共享一个常见的元素子集。以下清单使用 `Deployment` 来说明资源定义的主要结构元素：

```
apiVersion: apps/v1 ![1](img/1.png)
kind: Deployment ![2](img/2.png)
metadata: ![3](img/3.png)
    name: example-deployment ![4](img/4.png)
    labels: ![5](img/5.png)
        some-name: some-value
    annotations: ![6](img/6.png)
        some-name: some-value
# resource-specific YAML
```

![1](img/#co_introducing_helm_CO6-1)

该资源的 API 家族和版本。

![2](img/#co_introducing_helm_CO6-2)

资源的类型。与 `apiVersion` 结合使用，我们得到“资源类型”。

![3](img/#co_introducing_helm_CO6-3)

`metadata` 部分包含有关资源的顶级数据。

![4](img/#co_introducing_helm_CO6-4)

几乎每种资源类型都需要一个名称。

![5](img/#co_introducing_helm_CO6-5)

标签用于为您的资源提供 Kubernetes 可查询的“句柄”。

![6](img/#co_introducing_helm_CO6-6)

注解提供了一种方式，供作者将他们自己的键和值附加到资源上。

特别注意，在 Kubernetes 中，*资源类型* 由三部分信息组成：

API 组（或家族）

像 `Pod` 和 `ConfigMap` 这样的几种基本资源类型省略了这个名称。

API 版本

表示为 `v`，后跟主版本号和可选的稳定性标记。例如，`v1` 是稳定的“版本 1”，而 `v1alpha` 表示不稳定的“版本 1 alpha 1”。

资源种类

API 组内特定资源的（大写）名称。

###### 注意

完整的资源类型名称类似于 `apps/v1 Deployment` 或 `v1 Pod`（对于核心类型），Kubernetes 用户在谈论或写作时通常会省略组和版本。例如，在本书中，我们简单地写 `Deployment` 而不是 `apps/v1 Deployment`。完全合格的名称用于指定确切的版本或讨论在 CRD 中定义的资源类型。

因此，`apps/v1 Deployment` 表示 API 组 “apps” 有一个 “版本 1”（稳定的）资源类型称为 “Deployment”。

Kubernetes 支持两种主要格式来声明您所需的资源：JSON 和 YAML。严格来说，YAML 是 JSON 的 *超集*。所有的 JSON 文档都是有效的 YAML，但 YAML 增加了许多额外的功能。

在本书中，我们坚持使用 YAML 格式。我们发现它更易于阅读和编写，几乎所有 Helm 用户选择 YAML 而不是 JSON。但是，如果您有不同的偏好，Kubernetes 和 Helm 都支持纯粹的 JSON。

之前，我们介绍了术语 *清单*。清单只是 Kubernetes 资源序列化为其 JSON 或 YAML 格式。我们早先的 `Pod`、`ConfigMap`、`Deployment` 和 `Service` 每个都可以称为 *Kubernetes 清单*，因为它们是用 YAML 表示的资源。

## 图表

在本章中，我们已经讨论了 Helm 包。在 Helm 的术语中，一个包被称为 *图表*。这个名字是对 Kubernetes 的航海特性（希腊语中意为“船长”）和 Helm（船舶的驾驶机制）的一种演绎。图表规划了 Kubernetes 应用程序的安装方式。

一个图表是一组文件和目录，遵循图表规范来描述要安装到 Kubernetes 中的资源。第四章详细解释了图表结构，但在这里我们会介绍几个高级概念。

一个图表包含一个名为 *Chart.yaml* 的文件，描述了图表。它包含关于图表版本、图表名称和描述以及图表作者的信息。

一个图表也包含 *模板*。这些是 Kubernetes 清单（就像我们在本章早些时候看到的那样），可能带有模板化指令。我们将在第五章详细介绍这些内容。

一个图表还可能包含一个 *values.yaml* 文件，提供默认配置。这个文件包含参数，您可以在安装和升级期间进行覆盖。

这些是您在 Helm 图表中找到的基本内容，尽管还有其他内容我们将在第四章中介绍。然而，当您看到一个 Helm 图表时，它可能以解压或打包形式呈现。

*解压缩*的 Helm 图表只是一个目录。其中会包含一个*Chart.yaml*、一个*values.yaml*、一个*templates/*目录，以及可能的其他内容。*打包*的 Helm 图表包含与解压缩版本相同的信息，但它被打包成一个压缩文件（tar.gz）。

一个解压缩的图表表示为具有图表名称的目录。例如，名为*mychart*的图表将解压缩为一个名为*mychart/*的目录。相比之下，打包的图表具有图表的名称和版本，以及 `tgz` 后缀：`mychart-1.2.3.tgz`。

图表存储在*图表仓库*中，我们将在第七章中详细介绍。Helm 知道如何从仓库中下载和安装图表。

## 资源、安装和发布

为了将本节介绍的术语联系在一起，当将 Helm 图表安装到 Kubernetes 中时，将发生以下情况：

1.  Helm 读取图表（必要时进行下载）。

1.  它将这些值传递给模板，生成 Kubernetes 清单。

1.  清单被发送到 Kubernetes。

1.  Kubernetes 在集群内创建所请求的资源。

当安装 Helm 图表时，Helm 会根据需要生成多个资源定义。有些可能会创建一个或两个，而其他可能会创建数百个。当 Kubernetes 收到这些定义时，它将为它们创建资源。

Helm 图表可能包含多个资源定义。Kubernetes 将每个资源视为独立的实体。但在 Helm 的视角中，图表定义的所有资源都是相关联的。例如，我的 WordPress 应用可能有一个`Deployment`、一个`ConfigMap`、一个`Service`等等。但它们都属于同一个*图表*。当我安装它们时，它们都属于同一个*安装*。同一个图表可以安装多次（每次使用不同的名称）。因此，我可能会有同一个图表的多个安装，就像我可能会有同一种 Kubernetes 资源类型的多个资源一样。

这将引出最后一个术语。一旦安装我们的 WordPress 图表，我们就拥有了该图表的一个安装。然后我们使用 `helm upgrade` 升级该图表。现在，该安装就有了两个发布。每次我们使用 Helm 修改安装时，都会创建一个新的*发布*。

当我们安装 WordPress 的新版本时，将创建一个发布。但是，仅仅更改安装配置或回滚安装时也会创建一个发布。这是 Helm 的一个重要特性，我们将在第七章中再次看到。

## Helm 2 简介

熟悉 Helm 2 的人可能会注意到本书中缺少某些概念。书中没有提到 Tiller 或 gRPC。这些东西已经从 Helm 3 中移除，而 Helm 3 则是本书的主题。此外，本书的这个版本侧重于 Helm Charts 的第 2 版。尽管这很令人困惑，但 Helm Chart 的版本增量与 Helm 版本是分开的。因此，Helm v2 使用 Helm Charts v1，而 Helm v3 使用 Helm Charts v2。这些与 Helm Charts 第 1 版在声明依赖项方式上有几个重要的不同。Helm 2 和 Helm Charts v1 被视为不推荐使用。

# 结论

这里的材料应该为你准备好接下来的章节。但我们也希望它能让你了解为什么我们按照这样的方式构建了 Helm。Helm 的成功仅在于它能够使 Kubernetes 对于初次使用者和长期操作团队以及每天使用 Helm 的 SRE 更加易用。本书的其余部分致力于通过大量示例来解释如何充分利用 Helm，以及如何在安全和习惯的情况下这样做。
