# 第九章：操作员哲学

我们已经注意到操作员试图解决的问题，并且您已经详细了解了如何使用 SDK 构建操作员的示例。您还看到了如何使用 OLM 以一致的方式分发操作员。让我们试图将这些策略与支撑它们的战略思想联系起来，以理解一个存在的问题：操作员的目的是什么？

操作员概念源于站点可靠性工程（SRE）。在第一章中，我们谈到操作员作为软件 SRE。让我们回顾一些关键的 SRE 原则，以了解操作员如何应用它们。

# 每个应用程序的 SRE

SRE 始于 Google，以应对运行大型系统以及用户和功能数量不断增加的挑战。关键的 SRE 目标之一是使服务能够在不迫使运行它们的团队按比例增长的情况下增长。为了在没有庞大团队的情况下以戏剧性规模运行系统，SRE 编写代码来处理部署、运营和维护任务。SRE 创建的软件运行其他软件，保持其运行并随时间管理它。SRE 是一组广泛的管理和工程技术，其自动化是一个核心原则。您可能已经听说过它的目标被称为不同的名称，如“自治”或“自动驾驶”软件。在我们引入的操作员成熟度模型中，我们将其称为“自动驾驶”。

操作员和操作员框架使在 Kubernetes 上运行的应用程序实现这种自动化变得更加容易。Kubernetes 编排服务部署，使得对无状态应用程序进行一些水平扩展或故障恢复工作自动化。它将分布式系统资源表示为 API 抽象。使用操作员，开发人员可以将这些实践扩展到复杂的应用程序。

众所周知的“SRE 书籍” [*Site Reliability Engineering*](https://learning.oreilly.com/library/view/site-reliability-engineering/9781491929117/)（O’Reilly），由贝茜·拜尔等人（编辑）编写，是 SRE 原则的权威指南。Google 工程师卡拉·盖瑟在其中的评论代表了 SRE 的自动化元素：“如果在正常操作期间需要人工操作员接触您的系统，则存在错误。”^(1) SRE 通过编写代码来修复这些错误。操作员是在 Kubernetes 上为广泛的应用程序类别编程这些修复的逻辑位置。通过自动化其应用程序运行的常规杂务，操作员减少了人为干预的错误。

# 不要搞琐事

SRE 试图通过创建软件来执行操作系统所需的任务来减少琐事。在这个背景下，“琐事”被定义为“可自动化，战术性的，缺乏持久价值的工作，并且随着服务增长而线性扩展。”^(2)

## 可自动化：让您的计算机喜欢的工作

如果一个任务可以由机器完成，那么它是可以自动化的。如果任务需要人类判断的洞察力，那么机器无法完成。例如，费用报告会经过各种机器驱动的边界检查，但通常还需要最终的人工审核——检查自动流程标记为超出界限的条目，即使不是每一张收据都要审核。在界限内的报告的批准可能是可以自动化的；超出界限情况的最终接受或拒绝可能不能。如果软件能够自动化可以自动化的工作，并且这些工作是重复的，那么应该通过软件来自动化。建立软件来执行重复任务的成本可以在重复的生命周期中分摊。

## 跑步停留：没有持久价值的工作

将一些工作视为没有价值可能会让人感到不舒服，但在 SRE 的术语中，如果某项工作不会改变服务，则称其为“缺乏持久价值”。例如，备份数据库服务器就是一个例子。备份数据库不会使其运行更快、服务更多请求或在本质上更可靠。它也不会停止工作。尽管没有持久价值，备份显然是值得做的。这种工作通常是运维人员的一个很好的工作机会。

## 成长的烦恼：随系统扩展的工作

您可能会设计一个服务，使其在水平平面上扩展，以服务更多请求或运行更多服务实例。但是，如果添加新实例需要工程师配置计算机并将其连接到网络，那么扩展服务就远非自动化。在这种类型的繁重工作的最坏情况下，运维工作可能与您的服务呈线性增长。每增长 10%的服务——增加 10%的用户、每秒请求增加 10%，或使用 10%更多 CPU 的新功能——意味着增加 10%的守护劳动。

### 手动扩展：就像过去的糟糕日子一样

想象从 第一章 运行无状态 Web 服务器。您在三个虚拟机上部署了三个实例。要增加更多的 Web 服务器容量，您需要启动新的虚拟机，为它们分配（唯一的）IP 地址，并分配（每个 IP）端口，以便 Web 服务器二进制文件侦听。接下来，您需要通知负载均衡器新的端点，以便它可以将一些请求路由到那里。

如设计和配置的那样，您的简单无状态 Web 服务器确实可以根据需求增长。它可以通过将逐渐增加的负载分散到多个实例来为更多用户提供服务并添加更多功能。但是管理服务的团队将始终随之增长。随着系统变得更大，这种效果会变得更糟，因为增加一个虚拟机不会显著增加千个实例的容量。

### 自动化水平扩展：Kubernetes 副本

如果您将无状态的 Web 服务器部署在 Kubernetes 上，您可以通过几乎只需一个 `kubectl` 命令来进行水平扩展和缩减。这是 Kubernetes 作为 SRE 平台级自动化原则实施的一个例子。Kubernetes 抽象出了 Web 服务器运行的基础设施以及它们提供连接的 IP 地址和端口。在扩展时，您无需为每个新的 Web 服务器实例进行配置，或者在缩减时故意从您的 IP 范围中释放 IP。您无需编程负载均衡器以将流量传送到新实例。软件会自动完成这些繁琐的工作。

# 操作员：Kubernetes 应用可靠性工程

操作员扩展了 Kubernetes 的能力，将自动化原则应用于在平台上运行的复杂、有状态的应用程序。考虑一个管理具有其自身集群概念的应用程序的操作员。例如，当 etcd 操作员替换失败的 etcd 集群成员时，它通过配置新的 Pod 和现有集群的端点和认证来安排新的成员。

如果您负责管理内部服务的团队，操作员将使您能够将专家程序捕捉到软件中，并扩展系统的“正常运行”：即它可以自动处理的条件集。如果您正在开发一个 Kubernetes 本地应用程序，操作员可以让您考虑用户为运行您的应用程序而劳碌，并为他们省去麻烦。您可以构建不仅运行和升级应用程序的操作员，还可以响应错误或性能下降。

Kubernetes 中的控制循环会监视资源，并在它们不符合某些期望状态时做出反应。操作员允许您为代表您的应用程序的资源定制控制循环。通常首要的操作员关注点是操作数的自动部署和自助配置。在成熟模型的第一个级别之上，操作员应了解其应用程序的关键状态以及如何修复它。然后，操作员可以扩展以观察关键应用程序指标，并在需要时进行调整、修复或报告。

## 管理应用程序状态

应用程序通常具有需要在副本之间进行同步或维护的内部状态。一旦操作员处理安装和部署，它可以通过在动态群组的一组 Pod 中保持这种共享状态来沿着成熟模型走得更远。任何具有其自身集群概念的应用程序，如许多数据库和文件服务器，都具有这种共享应用程序状态。它可能包括认证资源、复制安排或编写者/读者关系。操作员可以为新的副本配置这种共享状态，允许其扩展或恢复应用程序的集群，并在新成员加入时修复它。操作员可能会处理其应用程序所需的外部资源。例如，考虑在副本死亡并被新副本替换时操作外部负载均衡器的路由规则。

## 发送到软件的黄金信号

Beyer 等人建议监控系统健康的“四个黄金信号”^(3)，这些是服务基本运行特征的良好起点。这些黄金信号在 SRE 书籍中得到了推广，传达了系统状态的重要信息，足以触发对工程师的呼叫^(4)。在设计 Operator 时，你应该将可能导致呼叫工程师的任何事情视为需要修复的错误。

*Site Reliability Engineering* 将四个黄金信号列为 *延迟*、*流量*、*错误* 和 *饱和度*。^(5) 对这四个领域的准确测量，根据最能代表特定应用程序状况的度量标准，确保了对应用健康的合理理解。当这些信号显示出已知条件、问题或错误时，Operator 可以采取特定于应用程序的措施。

延迟

延迟是完成某事所需的时间。通常被理解为请求和完成之间的经过时间。例如，在网络中，延迟被定义为在两点间发送数据包所需的时间。Operator 可以测量应用程序特定的内部延迟，如游戏客户端动作与游戏引擎响应之间的时间差。

流量

流量指服务请求的频率。每秒 HTTP 请求是衡量 Web 服务流量的标准。监控制度通常会将此测量分为静态资源和动态生成资源。对于数据库或文件服务器，监控每秒事务更有意义。

错误

错误是失败的请求，如 HTTP 500 系列错误。在 Web 服务中，你可能会得到 HTTP 成功代码，但在成功交付页面时看到脚本异常或其他客户端错误。超过某些延迟保证或性能策略，如在规定的时间内响应任何请求，也可能属于错误。

饱和度

饱和度是服务对有限资源的消耗的一种衡量。这些测量侧重于系统中最受限制的资源，通常是 CPU、内存和 I/O。监控饱和度的两个关键思想。首先，性能在资源完全利用之前就会变差。例如，当文件系统超过约 90%的容量时，某些文件系统的性能会变差，因为随着可用空间的减少，创建文件所需的时间也会增加。由于几乎任何系统中类似的效果，饱和度监视器通常应响应低于 100%的高水位标记。其次，测量饱和度可以帮助您在问题发生之前预测一些问题。通过将文件服务的剩余空间除以应用程序写入数据的速率，您的操作符可以估算剩余存储空间满时的时间。

操作符可以通过测量和响应需要越来越复杂的操作任务的黄金信号来迭代地朝着自动驾驶运行服务的方向发展。每当你的应用程序需要人工帮助时应用这种分析，你就有了一个操作符迭代开发的基本计划。

# 高效操作符的七个习惯

操作符起源于 2015 年至 2016 年期间在 CoreOS 的工作。在那里构建的操作符的用户体验以及在 Red Hat 和更广泛的社区中继续发展的操作符已帮助完善了作为 Kubernetes 操作符概念的七项指南：^(6)

1.  *操作符应作为单个 Kubernetes 部署运行*。

    在第二章中，你通过一个清单安装了 etcd 操作符，而没有使用第八章介绍的 OLM 机制。虽然你提供了 CSV 和其他资产来为操作符创建 OLM 捆绑包，但 OLM 仍然使用单个清单来代表你部署操作符。

    举例说明，尽管通常需要配置 RBAC 和服务账户，但你可以用一个命令将 etcd 操作符添加到 Kubernetes 集群中。这只是一个部署：

    ```
    $ `kubectl` `create` `-f` `https://raw.githubusercontent.com/``\ `  `kubernetes-operators-book/chapters/master/ch03/`
           `etcd-operator-deployment.yaml`

    ```

1.  *操作符应在集群上定义新的自定义资源类型*。

    回想起第二章中的 etcd 示例。你创建了一个 CRD，在其中定义了一种新类型的资源，即 EtcdCluster。该类型代表由操作符管理的运行中的 etcd 集群的实例。用户通过创建新的应用程序实例的自定义资源来创建新的应用程序实例。

1.  *操作符在可能的情况下应使用适当的 Kubernetes 抽象*。

    当 API 调用可以以更一致和广泛测试的方式完成相同的操作时，不要编写新代码。一些非常有用的操作符只是以适合其应用程序的方式操作一些标准资源集。

1.  *操作符的终止不应影响操作数*。

    当一个操作符停止或从集群中删除时，它管理的应用程序应继续运行。返回你的集群，并删除 etcd 或访问者站点操作符。虽然你不会自动从故障中恢复，但在操作符不存在的情况下，你仍然可以使用操作对象应用程序的功能。即使相应的操作符没有运行，你仍然可以访问访问者站点或从 etcd 检索键值对。

    注意，删除一个 CRD 确实会影响操作对象应用程序。实际上，删除 CRD 将会删除其 CR 实例。

1.  *操作符应理解由任何先前版本创建的资源类型*。

    操作符应与其前身的结构向后兼容。这要求设计时要非常小心和简洁，因为你在版本 1 中定义的资源将长期存在。

1.  *操作符应协调应用程序的升级*。

    操作符应协调其操作对象的升级，可能包括在应用程序集群中进行滚动升级，几乎肯定包括在出现问题时回滚到先前版本的能力。保持软件最新是必要的努力，因为只有最新的软件才具有对错误和安全漏洞的最新修复。自动化这种升级工作是操作符的理想任务。

1.  *操作符应进行彻底测试，包括混沌测试*。

    你的应用程序及其与基础设施的关系构成一个复杂的分布式系统。你将依赖你的操作符来管理这个系统。[混沌测试](https://oreil.ly/K8IUR)是有意引发系统组件故障，以发现意外错误或降级的方法。建立一个测试套件，让你的操作符经历模拟错误和 pod、节点以及网络突然消失的情况，从而查看故障在哪里出现，或在它们的依赖关系崩溃时如何在组件之间进行级联。

# 总结

操作符往往会通过自动安装、无缝应用升级等不同成熟阶段发展，最终进入“自动驾驶”的稳定状态，在这种状态下，它们会响应和纠正性能和稳定性的突发问题。每个阶段的目标都是减少人工操作。

制作一个操作符来分发、部署和管理你的应用程序，使其更容易在 Kubernetes 上运行，并允许应用程序利用 Kubernetes 的功能。一个遵循此处概述的七个习惯的操作符可以轻松部署，并可以通过 OLM 管理其整个生命周期。这种操作符使其操作对象更易于运行、管理，可能还可以实现。通过监控其应用程序的关键信号，操作符可以做出明智的决策，解放工程师免受机械性操作任务的困扰。

^(1) Beyer 等人（编辑），*网站可靠性工程*，119 页。

^(2) 贝尔等人（编），《**现场可靠性工程**》，120 页。

^(3) 贝尔等人（编），《**现场可靠性工程**》，139 页。

^(4) 贝尔等人（编），《**现场可靠性工程**》，140 页。

^(5) 贝尔等人（编），《**现场可靠性工程**》，139 页。

^(6) 布兰登·菲利普斯，《引入操作员》，CoreOS 博客，2016 年 11 月 3 日，[*https://oreil.ly/PtGuh*](https://oreil.ly/PtGuh)。
