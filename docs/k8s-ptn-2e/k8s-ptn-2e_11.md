# 第八章：周期性作业

*周期性作业*模式通过添加时间维度扩展了*批处理作业*模式，并允许通过时间事件触发执行工作单元。

# 问题

在分布式系统和微服务的世界中，有一个明显的趋势，即使用 HTTP 和轻量级消息传递进行实时和事件驱动的应用程序交互。然而，无论软件开发的最新趋势如何，作业调度都有着悠久的历史，而且仍然很重要。周期性作业通常用于自动化系统维护或管理任务。它们还与需要定期执行特定任务的业务应用程序相关联。这里的典型例子包括通过文件传输进行业务-to-业务集成，通过数据库轮询进行应用程序集成，发送新闻通讯邮件以及清理和归档旧文件。

处理系统维护目的的周期性作业的传统方式是使用专门的调度软件或 cron。然而，对于简单用例，专用软件可能昂贵，而在单个服务器上运行的 cron 作业难以维护并且代表单点故障。这就是为什么开发人员经常倾向于实现既能处理调度方面又能执行需要执行的业务逻辑的解决方案。例如，在 Java 世界中，像 Quartz、Spring Batch 以及使用 ScheduledThreadPoolExecutor 类的自定义实现可以运行时间任务。但与 cron 类似，这种方法的主要困难在于使调度能力具有弹性和高可用性，这导致资源消耗很高。此外，使用这种方法，基于时间的作业调度程序是应用程序的一部分，并且为了使调度程序高度可用，整个应用程序必须高度可用。通常，这涉及运行应用程序的多个实例，并同时确保只有一个实例处于活动状态并调度作业，这涉及领导选举和其他分布式系统挑战。

最终，一个简单的服务每天只需复制几个文件可能最终需要多个节点、分布式领导选举机制等。Kubernetes CronJob 实现通过允许使用众所周知的 cron 格式调度作业资源来解决了所有这些问题，并且让开发人员只需关注实现要执行的工作，而不是时间调度方面。

# 解决方案

在第七章，“批处理作业”中，我们看到了 Kubernetes Jobs 的用例和能力。所有这些也适用于本章，因为 CronJob 原语建立在 Job 之上。CronJob 实例类似于 Unix crontab（cron 表）的一行，并管理作业的时间方面。它允许在指定时间周期性地执行作业。参见示例 8-1 以查看样本定义。

##### 示例 8-1\. CronJob 资源

```
apiVersion: batch/v1
kind: CronJob
metadata:
  name: random-generator
spec:
  schedule: "*/3 * * * *"  ![1](img/1.png)
  jobTemplate:
    spec:
      template:            ![2](img/2.png)
        spec:
          containers:
          - image: k8spatterns/random-generator:1.0
            name: random-generator
            command: [ "java", "RandomRunner", "/numbers.txt", "10000" ]
          restartPolicy: OnFailure
```

![1](img/#co_periodic_job_CO1-1)

每三分钟运行一次的 Cron 表达式。

![2](img/#co_periodic_job_CO1-2)

使用与常规作业相同的规范的作业模板。

除了作业规范外，CronJob 还有额外的字段来定义其时间特性：

`.spec.schedule`

用于指定作业计划的 crontab 条目（例如，`0 * * * *` 表示每小时运行一次）。您还可以使用 `@daily` 或 `@hourly` 等快捷方式。请参阅 [CronJob 文档](https://oreil.ly/Qc3TA) 获取所有可用选项。

`.spec.startingDeadlineSeconds`

如果错过了计划的执行时间，启动作业的截止时间（以秒计）。在某些用例中，任务只有在特定时间内执行才有效，而且如果执行延迟，可能会由于计算资源不足或其他依赖关系缺失而导致任务无法按时执行。例如，如果由于缺乏计算资源或其他缺失的依赖关系而未能在期望的时间内执行作业，则最好跳过执行，因为其应处理的数据已经过时。不要使用少于 10 秒的截止时间，因为 Kubernetes 每 10 秒才会检查一次作业状态。

`.spec.concurrencyPolicy`

指定如何管理由同一 CronJob 创建的作业的并发执行。默认行为 `Allow` 即使前一个作业尚未完成也会创建新的作业实例。如果不希望出现这种情况，可以选择如果当前作业尚未完成，则跳过下次运行 `Forbid` 或取消当前正在运行的作业并启动新作业 `Replace`。

`.spec.suspend`

暂停所有后续执行而不影响已启动的执行。请注意，这与作业的 `.spec.suspend` 不同，因为它会暂停新作业的启动，而不是作业本身。

`.spec.successfulJobsHistoryLimit` 和 `.spec.failedJobsHistoryLimit`

定义如何保留完成和失败作业以进行审核目的的字段。

CronJob 是一种非常专门化的原语，仅在工作单元具有时间维度时适用。即使 CronJob 不是通用的原语，它也是 Kubernetes 能力如何相互构建并支持非云本地使用案例的一个很好的例子。

# 讨论

正如你所见，CronJob 是一个相当简单的原语，为现有的作业定义添加了集群化、类似 cron 的行为。但是，当它与其他原语如 Pod、容器资源隔离以及 Kubernetes 的其他特性（比如第六章，“自动放置”或第四章，“健康探针”中描述的特性）结合使用时，它就变成了一个非常强大的作业调度系统。这使得开发人员能够专注于问题领域，并实现一个仅负责执行业务逻辑的容器化应用程序。调度是在应用程序之外完成的，作为平台的一部分，具有其所带来的所有附加好处，如高可用性、弹性、容量和基于策略的 Pod 放置。当然，类似于作业实现时，当实现一个 CronJob 容器时，你的应用程序必须考虑重复运行、无运行、并行运行或取消的所有边界和失败情况。

# 更多信息

+   [周期性作业示例](https://oreil.ly/yINcj)

+   [CronJob](https://oreil.ly/9096p)

+   [Cron](https://oreil.ly/ZPavq)

+   [Crontab 规范](https://oreil.ly/Oi3b5)

+   [Cron 表达式生成器](https://oreil.ly/xYymj)
