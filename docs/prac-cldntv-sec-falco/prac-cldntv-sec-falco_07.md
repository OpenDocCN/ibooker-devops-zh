# 第五章：数据丰富化

Falco 的架构允许您从不同的数据源捕获事件，正如您所了解的那样。此过程提供原始数据，可能非常丰富，但如果不与正确的上下文配对，对运行时安全性并不是非常有用。这就是为什么 Falco 首先提取，然后用上下文信息丰富原始数据，以便规则作者可以轻松使用。通常，我们将这些信息称为事件**元数据**。获取元数据可能是一个复杂的任务，而有效获取它更加复杂。

您已经看到*libscap*中的系统状态收集功能和*libsinsp*中实现的状态引擎（在第三章讨论过），这些都是这项活动的核心，但还有更多内容等待探索。在本章中，我们将深入探讨 Falco 堆栈的设计方面，帮助您更好地理解数据丰富化的工作方式。特别是，我们将展示*libsinsp*用于系统调用事件获取系统、容器和 Kubernetes 元数据的高效分层方法。这使您能够根据您的用例访问您需要的不同上下文信息，例如容器的 ID 或发生可疑事件的 Pod 的名称。最后，我们将展示插件如何实现其自己的数据丰富化机制，为 Falco 的另一个主要数据源打开无限的可能性。

# 理解 Syscalls 的数据丰富化

理解数据丰富化的工作原理将帮助您充分理解 Falco 的机制。此外，虽然数据丰富化通常可以即插即用，但 Falco 支持的每个上下文都有自己的实现，可能需要特定的配置。了解实现细节将有助于您进行故障排除和优化 Falco。

*Falco*中的**数据丰富化**指的是通过解码原始数据或从补充源收集事件元数据，并将其提供给规则引擎的过程。然后，您可以将此元数据用作规则条件和输出格式化的字段。Falco 将收集的元数据组织成一组字段类别，因此您可以轻松识别它们所属的上下文。（您可以在第六章找到支持的字段的完整列表，或者如果您的 Falco 安装在手边，可以键入`**falco --list**`来查找。）

数据丰富化的一个重要例子是使用系统调用作为数据源，您在第四章已经了解过。由于 syscalls 对每个应用程序都至关重要，它们几乎发生在每个上下文中。然而，直接由 syscall 提供的信息如果没有上下文是没有用处的，因此收集和连接周围信息变得至关重要。

表 5-1 显示了 Falco 为系统调用收集的不同类别的元数据以及每个数据丰富层关联的字段类别。

表 5-1\. 系统调用的上下文元数据

| 上下文 | 元数据 | 字段类别 |
| --- | --- | --- |

| 操作系统 | 进程和线程 文件描述符

用户和组

网络接口 | `proc`, `thread`, `fd`, `fdlist`, `user`, `group` |

| 容器 | ID 和名称 类型

镜像名称

特权

挂载点

健康检查 | `container` |

| Kubernetes | 命名空间 Pod

复制控制器

服务

副本集

部署 | `k8s` |

数据丰富过程在用户空间中进行，涉及 Falco 堆栈的多个组件。最重要的是，每次规则引擎请求时必须立即提供元数据。因此，尝试从其他互补来源即时收集元数据是不可行的，因为这样做可能会阻塞规则引擎和传入事件的整个流程。

因此，数据丰富涉及两个不同的阶段。第一个阶段通过大量收集 Falco 启动时存在的数据来初始化本地状态，第二个阶段则在 Falco 运行时持续更新本地状态。拥有本地状态允许 Falco 立即提取元数据。这种设计在所有实现层中都是共享的，你将在以下章节中了解到。

## 操作系统元数据

正如你在第三章学到的，*libscap* 和 *libsinsp* 协同工作，提供创建和更新由多个状态表组成的分层结构中的上下文信息所需的所有基础设施（如果需要复习，请参见图 3-4）。这些表包括关于以下信息的信息：

+   进程和线程

+   文件描述符

+   用户和组

+   网络接口

从高层次来看，收集系统信息的机制相对简单。在启动时，*libscap* 的任务之一是扫描[*进程信息伪文件系统*](https://oreil.ly/xso1E)，或称为*procfs*，它为 Linux 内核数据结构提供用户空间接口，并包含初始化状态表所需的大部分信息。它还使用标准 C 库提供的函数来收集系统信息（不在*/proc*中可用），这些函数最终从底层操作系统获取数据（例如，`getpwent` 和 `getgrent` 分别用于用户和组列表，以及 `getifaddrs` 用于网络接口列表）。此时，初始化阶段完成。

###### 提示

*libscap* 和 *libsinsp* 依赖于主机的 procfs 来访问主机的系统信息。这在 Falco 运行在主机上时是默认的，因为它可以直接访问主机的 */proc*。然而，在容器中运行 Falco 时，容器内的 */proc* 指的是不同的命名空间。在这种情况下，你可以通过 `HOST_ROOT` 环境变量配置 *libscap* 来从另一路径读取信息。如果设置了 `HOST_ROOT`，*libscap* 将使用其值作为查找系统路径的基路径。例如，在容器中运行 Falco 时，通常的方法是将主机的 */proc* 挂载到容器内的 */host/proc* 并设置 `HOST_ROOT` 为 */host*。通过这种设置，*libscap* 将从 */host/proc* 读取信息，因此它将使用主机的 procfs 提供的信息。

之后，*libsinsp* 通过其状态引擎发挥作用（见 图 5-1）。它通过检查驻留在内核空间的驱动程序提供的持续捕获的系统调用流来更新表格。在初始化阶段之后，Falco 将不需要进行任何系统调用或从 Linux 内核获取更新。这种方法的双重好处是不会在系统中创建噪音并且对性能影响很低。此外，这种技术使 *libsinsp* 能够以低延迟发现系统变化，从而使 Falco 能够作为流式引擎（其设计的一个重要目标）运行。

最后需要注意的是，*libsinsp* 在将事件传递给规则引擎之前更新状态表。这确保了当条件或输出需要元数据时，它始终可用且一致。然后，你可以在你在 表格 5-1 中看到的字段类集合中找到系统元数据：`proc`、`thread`、`fd`、`fdlist`、`user` 和 `group`。

这组信息表示了使规则作者能够使用系统调用事件的基本元数据。想想看：你如何在规则中使用数值文件描述符？使用文件名要好得多！

![](img/pcns_0501.png)

###### 图 5-1\. 初始化阶段之前（1）和之后（2）的系统状态收集

这个数据丰富层产生的系统信息（即状态表）也是收集容器级上下文信息所必需的。接下来我们会详细看一下这些信息。

## 容器元数据

额外的基本上下文信息存储在容器运行时层中。*容器运行时* 是可以在主机操作系统上运行容器的软件组件。通常负责管理容器映像和在系统上运行的容器的生命周期。它还负责管理与每个运行中容器相关的一组信息，并将该信息提供给其他应用程序。

因为 Falco 是一个云原生运行时安全工具，它需要能够处理容器信息。为了实现这一目标，*libsinsp* 与最常用的容器运行时环境合作，包括 Docker、Podman 和与 CRI 兼容的运行时（如 containerd 和 CRI-O）。

当 *libsinsp* 在主机上找到一个运行的容器运行时时，几乎在所有情况下，容器元数据增强功能都能够立即正常工作。例如，*libsinsp* 尝试使用 Docker 的 Unix 套接字 */var/run/docker.sock*；如果存在，则 *libsinsp* 将自动连接并开始抓取容器元数据。*libsinsp* 对 Podman 和 containerd 也是如此。对于其他与 CRI 兼容的运行时，你需要使用 `--cri` 命令行标志将套接字路径传递给 Falco（例如，对于 CRI-O，你需要传递 `/var/run/crio/crio.sock`）。

###### 提示

如果设置了环境变量`HOST_ROOT`，*libsinsp* 将使用其值作为查找这些 Unix 套接字时的基本路径。例如，当在容器中运行 Falco 时，通常会设置 `HOST_ROOT=/host` 并将 */var/run/docker.sock* 挂载到容器内的 */host/var/run/docker.sock*。

无论使用哪种容器运行时，在初始化时，*libsinsp* 都会请求所有运行中容器的列表，并用它来初始化内部缓存。同时，*libsinsp* 更新运行进程和线程的状态表，将每个进程和线程与其相应的容器 ID（如果有）关联起来。

*libsinsp* 通过使用来自驱动程序的系统调用流来处理后续更新（类似于处理系统信息）。由于容器信息始终与进程关联，*libsinsp* 跟踪所有新的进程和线程。当检测到一个新进程或线程时，它会在内部缓存中查找相应的容器 ID。如果容器 ID 不在缓存中，*libsinsp* 将查询容器运行时以收集丢失的数据。

最终，发生在容器中的每个系统调用生成的事件都有一个进程或线程 ID，映射到一个容器 ID，并因此映射到容器元数据（如 图 5-2 所示）。因此，当规则引擎需要此元数据时，*libsinsp* 会从状态表中查找并返回系统信息以及容器元数据。你可以在字段类 `container` 中找到可用的容器元数据，这些数据可以用于条件和输出格式化。

![](img/pcns_0502.png)

###### 图 5-2\. *libsinsp* 状态层次结构中的容器信息

注意，字段 `container.id` 可以包含容器 ID 或特殊值 `host`。这个特殊值表示事件未发生在容器内。条件 `container.id != host` 是表达仅在容器上下文中应用规则的常见方式。

在最终的数据增强层中，Falco 收集与系统调用相关联的 Kubernetes 元数据。我们接下来将看看它是如何工作的。

## Kubernetes 元数据

Kubernetes 是云原生计算基金会的旗舰项目，是一个用于管理工作负载和服务的开源平台。它引入了许多新概念，使得管理和扩展集群更加容易，并且是当今最流行的容器编排系统。

Kubernetes 的一个关键特性是将您的应用程序封装在称为 *Pods* 的对象中，每个 Pod 包含一个或多个容器。Pods 是短暂的对象，您可以快速部署和轻松复制。Kubernetes 中的 *Services* 是一种抽象，允许您将一组 Pods 暴露为单个网络服务。最后，Kubernetes 允许您将这些和许多其他对象安排到 *namespaces* 中，这些对象允许将单个集群分区为多个虚拟集群。

虽然这些概念极大地便于管理和自动化集群，但它们也引入了关于应用程序在何处以及如何运行的一系列上下文信息。了解这些信息至关重要，因为如果不知道事件发生的地点（例如，在哪个命名空间或 Pod 中），知道 Kubernetes 集群中发生了某事并没有什么用处。Falco 收集的信息包括容器镜像名称、Pod 名称、命名空间、标签、注释和暴露的服务名称，以尽可能准确地展示您的部署和应用。这对于运行时警报和保护基础设施至关重要，因为您通常更关心显示异常行为的服务或部署，而不是获取容器 ID 或其他难以关联的信息。作为云原生工具，Falco 可以轻松获取此元数据并将其附加到事件中。

与前几节中看到的操作系统和容器元数据收集机制类似，此功能允许 Falco 通过添加 Kubernetes 元数据来丰富系统调用事件。要完全支持 Kubernetes，您必须通过向 Falco 传递两个命令行选项来选择加入：

`--k8s-api`（或简写为 `-k`）

这通过连接到指定的 API 服务器（例如，`http://admin:password@127.0.0.1:8080`）来启用 Kubernetes 支持。

`--k8s-api-cert`（或简写为 `-K`）

这提供了证书材料来对用户进行身份验证，并（可选地）验证 Kubernetes API 服务器的身份。

更多详细信息请参阅第十章。

###### 提示

当 Falco 在 Pod 中运行时，Kubernetes 会将该信息注入到容器中，因此您只需要设置：

```
-k https://$(KUBERNETES_SERVICE_HOST) 
-K /var/run/secrets/kubernetes.io/serviceaccount/token
```

大多数安装方法使用此策略自动获取这些值。

一旦配置了 Kubernetes 支持，*libsinsp* 将从 Kubernetes 获取所有必要的数据，以创建和维护集群状态的本地副本。但是，与从主机本地获取元数据的其他丰富机制不同，*libsinsp* 必须连接到 Kubernetes API 服务器（通常是远程端点）以获取集群信息。由于这种差异，实现设计需要考虑性能和可扩展性问题。

典型的 Falco 部署（如 图 5-3 所示）在集群中的每个节点上运行一个 Falco 传感器。在启动时，每个传感器连接到 API 服务器以收集集群数据并在本地构建初始状态。从此以后，每个传感器将使用 [Kubernetes watch API](https://oreil.ly/g0hCZ) 定期更新本地状态。

![](img/pcns_0503.png)

###### 图 5-3\. 使用 [DaemonSet](https://oreil.ly/WTTGU) 实现的 Falco 部署，以确保所有节点运行一个 Pod 的副本

由于 Falco 传感器在集群中分布（每个节点一个），并从 API 服务器获取数据 —— 因为从 Kubernetes 收集某些资源类型可能导致响应巨大，严重影响 API 服务器和 Falco —— *libsinsp* 具有避免拥塞的机制。首先，在下载每个数据块之间等待一段时间。Falco 允许您通过更改 */etc/falco/falco.yaml* 中的一个值来调整该等待时间以及几个其他参数。

更重要的是，可以仅从 API 服务器请求针对目标节点的相关元数据。这非常有用，因为 Falco 的架构是分布式的，所以每个传感器只需从事件发生的节点获取数据。如果您希望在具有数千个节点的集群上扩展 Falco，则这种优化至关重要。要启用此功能，请在 Falco 命令行参数中添加 `--k8s-node` 标志，并将当前节点名称作为值传递。通常可以通过 Kubernetes 的 [Downward API](https://oreil.ly/F1Dnv) 轻松获取此名称。^(3)

如果不包括 `--k8s-node` 标志，*libsinsp* 仍然能够从 Kubernetes 获取数据，但每个 Falco 传感器将不得不请求整个集群的数据。这可能会在大型集群上引入性能损失，因此我们强烈不建议这样做。（您将在 第三部分 了解更多关于在生产 Kubernetes 集群上运行 Falco 的内容。）

当 Kubernetes 元数据可用时，您将在 `k8s` 字段类中找到它们。Falco 的许多默认规则在其条件中包含 `k8s` 字段。当使用 `-pk` 命令行选项运行 Falco 时，Falco 会自动将最关键的 Kubernetes 元数据附加到所有通知的输出中，如下所示，我们已对其进行了美化以提高可读性（更多信息请参阅 “输出设置”）：

```
15:29:40.515013896: Notice System user ran an interactive command
	(user=bin user_loginuid=-1 command=login container_id=46c99eea62a8
	image=docker.io/library/nginx)
	k8s.ns=default k8s.pod=my-app-84d64cb8fb-zmxgz
	container=46c99eea62a8
```

这个输出是刚学习到的复杂机制的结果，它允许你获取准确和上下文化的信息，以立即识别刚刚发生的事件及其位置。

到目前为止，我们只讨论了 Falco 对系统调用数据丰富化的过程。尽管这对大多数用户可能是最相关的信息，但你应该知道，Falco 还提供了自定义丰富化机制。接下来我们快速看一下如何实现这些机制。

# 使用插件进行数据丰富化

插件可以通过添加新的数据源和定义新的字段来扩展 Falco，以描述如何使用这些新事件。正如你在第四章中所了解到的，一个提供字段提取能力的插件可以处理其他插件或核心库提供的事件。虽然现在可能还不明显，但具有这种能力的插件已具备提供自定义数据丰富化机制的一切条件。首先，它可以从任何数据源接收数据。其次，它可以定义新的字段。基本上，它允许插件作者实现逻辑来返回这些字段的值，从而潜在地提供额外的元数据。这打开了实现自定义数据丰富化的可能性。

当这样一个插件运行时，*libsinsp* 会为每个传入的事件调用插件函数进行字段提取。该函数接收事件的原始数据负载和规则引擎所需的字段列表。插件 API 接口并不对使提取过程工作施加其他限制。尽管数据丰富化在上述流程中是可能的，但插件作者仍需考虑使用情况的所有影响；例如，插件将需要管理本地状态和随后的更新。因此，提取字段和丰富化事件完全取决于插件作者。API 仅提供了基本工具。

第十四章 展示了如何实现一个插件。如果你对此感兴趣，我们建议先阅读下一章关于字段和过滤器，这样你就能更全面地了解数据提取的工作方式。

# 结论

本章展示了 Falco 内部工作的方式，以提供丰富的元数据。Falco 将这些元数据作为字段提供，你可以在规则的条件中使用这些字段。继续阅读，了解如何使用字段仅过滤那些真正与你需求相关的事件。

^(1) 在较早的 Falco 版本中，Kubernetes 审计日志是一个内置的数据源。从 Falco 0.32 开始，这个数据源已被重构为一个插件。

^(2) [容器运行时接口（CRI）](https://oreil.ly/fiCGp) 是由 Kubernetes 引入的插件接口，允许 kubelet 使用任何实现 CRI 的容器运行时。

^(3) 下行 API 允许容器在不使用 Kubernetes API 服务器的情况下获取有关自身或集群的信息。它可以通过环境变量暴露当前节点名称，这个名称可以在 Falco 命令行参数中使用。
