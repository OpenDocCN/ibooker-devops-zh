# 第十章：配置和运行 Falco

在前一章中，您学习了如何在生产环境中安装 Falco。然而，您仍需了解其配置系统的工作方式。学习如何更改其设置对于随时间管理和适应您的需求至关重要。您可以在安装期间或安装后立即配置 Falco，在更新到新版本时或任何时候根据您的需求进行配置。

本章将帮助您理解和使用可用的设置。首先，我们将解释主要的干预领域：命令行选项、环境变量、配置文件和规则文件。然后，我们将深入探讨每一个。您还将找到关于生产用例的宝贵建议，以及一些微调 Falco 配置的提示。在章节末尾，您将找到一个专门介绍配置插件的部分，并展示如何更新运行中的 Falco 实例配置。

# 配置 Falco

您可以通过其设置来配置 Falco，我们将这些设置分为三类：

命令行选项和环境变量

命令行选项和环境变量是您运行 Falco 所需的首要设置。其中大多数设置允许 Falco 与您的系统进行通信，这对于系统仪表化和数据丰富化特别重要。这里的其他设置可以帮助您适应特定需求或帮助故障排除。

配置文件

您可以通过主配置文件几乎配置任何 Falco 行为，根据需要进行自定义。例如，您可以加载规则文件，激活所需的输出通道，并在需要时使用插件。默认情况下，Falco 在 */etc/falco/falco.yaml* 中查找此文件，但您可以使用命令行选项指定不同的路径。

规则集

Falco 自带丰富的默认规则集，以便您可以立即开始使用它。然而，规则集可能是定制化最关键的方面。它代表了 Falco 引擎的配置，并设置了 Falco 将检测到的内容。按照惯例，规则文件位于 */etc/falco*。

在详细讨论每个类别之前，我们想向您展示 Falco 如何根据您的安装方式进行变化。

# 安装方法之间的差异

无论您选择哪种安装方法，Falco 的配置区域始终相同。但是，您可以更改设置的方式可能略有不同。

## 主机安装

如果您使用软件包管理器安装了 Falco，则可以直接在 systemd 单元文件中指定命令行选项和环境变量，该文件位于 */usr/lib/systemd/user/falco.service*。使用 `systemctl edit falco` 是一种方便的方法。完成后，请记得使用 `systemctl restart falco` 重新启动服务。

如果您不使用包管理器，运行 Falco 完全由您决定，包括传递命令行选项和设置环境变量。在这种情况下，您可以手动创建一个 systemd 单元。您可以使用 [*falco-service* 文件的源代码](https://oreil.ly/0LcF3) 作为示例。

无论您使用哪个包，您都会在 */etc/falco* 下找到 Falco 的配置文件和规则文件。您可以直接编辑这些文件，然后重新启动 Falco。

## 容器

Falco 的容器镜像允许您指定要运行的命令，默认为 `/usr/bin/falco`。如果需要传递命令行选项，请通过容器运行时的 CLI 进行。例如，在 Docker 中，要传递 `--version`，可以使用：

```
$ docker run --rm -it falcosecurity/falco /usr/bin/falco --version
```

请注意，*falcosecurity/falco* 容器镜像的入口点是一个脚本，尝试自动安装驱动程序。如果要跳过安装，需要将 `SKIP_DRIVER_LOADER` 环境变量设置为任何非空值。在 Docker 中，可以使用 `-e` 选项设置环境变量。^(1) 例如，要获取版本并同时跳过驱动程序安装，可以运行：

```
$ docker run --rm -it -e SKIP_DRIVER_LOADER=y \
 falcosecurity/falco /usr/bin/falco --version
```

Falco 容器镜像还捆绑了默认的配置文件和规则文件。如果需要修改其中任何文件，通常的做法是制作文件的外部副本（例如，*/etc/falco/falco.yaml*），然后挂载到容器中。您可以从二进制包中获取配置和规则文件（确保与容器中运行的 Falco 版本匹配），根据需要进行修改。然后，在 Docker 中，使用 `-v` 选项将修改后的文件挂载到容器中。^(2)

## Kubernetes 部署

在 Kubernetes 中部署 Falco 时，还需在 DaemonSet 或 Deployment 清单中指定命令行选项和环境变量。如果使用 Helm 或来自 第九章 的示例清单，部署将已经配置了连接到您的容器运行时和 Kubernetes API 服务器的所有选项。如果需要修改选项，请查找相应的 [Falco 图表配置](https://oreil.ly/9CsSk) 或直接修改 [清单](https://oreil.ly/L6rs9)。

另一个重要的区别是配置和规则文件存储在 ConfigMap 内，其内容会覆盖容器镜像中包含的文件。对于 Helm 用户，维护者会将 Falco 的图表、配置和规则文件与 Falco 发行版同步更新。另一方面，如果使用清单文件，您完全可以确保 ConfigMap 嵌入了正确的文件。

# 命令行选项和环境变量

在运行 Falco 时，有时通过命令行选项或设置环境变量是更改某些设置的唯一方式。您通过命令行配置的设置始终优先于从配置文件加载的设置。

要获取 Falco 的命令行选项完整列表，请运行 `falco --help`。Falco 将按字母顺序打印每个选项（以及简要描述）。可用选项可能根据 Falco 版本的不同而变化。有疑问时，请始终参考 `falco --help`。

在本节的其余部分，为了帮助您熟悉最重要的设置，我们按功能对其进行分组。我们还提供了关于使用环境变量的详细信息，这些信息在 `falco --help` 中找不到。

## 配置设置

在 表 10-1 中显示的两个命令行选项与 Falco 的配置文件相关（默认位于 */etc/falco/falco.yaml*）。第一个选项允许您从不同位置加载配置文件；第二个选项允许您即时覆盖某些配置值。通常情况下不需要使用它们，但在故障排除时可能会很有用。此外，在生产环境中运行 Falco 时，请确保没有人错误地设置它们，以便 Falco 使用正确的配置文件和预期的设置。

表 10-1\. 配置命令行选项

| 选项 | 描述 |
| --- | --- |
| `-c` | 设置 Falco 将加载的配置文件路径。如果未设置，则 Falco 将使用默认路径： */etc/falco/falco.yaml*。 |
| `-o`, `--option *<key>*=*<val>*` | 通过将值 `*<val>*` 设置为指定的配置选项 `*<key>*` 来覆盖配置文件中的值。您可以使用点表示法（`.`）指定嵌套选项，或使用方括号表示法（`[]`）访问列表：例如，`-o key.subkey.list[0]=myValue`。 |

## 仪表设置（仅系统调用）

如您在第 4 和 9 章节中学到的，Falco 默认使用内核模块驱动程序。您可以通过设置 `FALCO_BPF_PROBE` 环境变量切换到 eBPF 探针。您可以将其设置为您想使用的探针路径，例如 `FALCO_BPF_PROBE="/path/to/falco-bpf.o"`。否则，您可以将其设置为空字符串（`FALCO_BPF_PROBE=""`），Falco 将默认使用 *~/.falco/falco-bpf.o*。

当您在容器或 Kubernetes 中运行 Falco 时，容器镜像支持 `FALCO_BPF_PROBE` 控制即时驱动程序安装，以及其他环境变量。 （*falco-driver-loader* 脚本暴露了大部分，因此您也可以使用 `falco-driver-loader --help` 获取更多信息。）现在让我们看看这些环境变量：

`DRIVERS_REPO`

如果您创建了预构建驱动程序的存储库（无论是内核模块还是 eBPF 探针），可以使用此选项指示脚本从您的存储库下载驱动程序。驱动程序存储库以以下 URL 结构托管文件：

*<DRIVERS_REPO>/<DRIVER_VERSION>/falco_<OS_ID>​_<KER⁠NEL_RELEASE>_<KERNEL_VERSION>.[ko|o]*

此变量允许您设置您存储库的基本 URL（末尾没有斜杠）。如果您在离线环境中运行 Falco 或者不希望从互联网下载预构建的驱动程序，可能希望使用此设置。如果未设置，此变量默认为 The Falco Project 的 [public driver repository](https://oreil.ly/vsE8X)。

`DRIVER_INSECURE_DOWNLOAD`

如果您的驱动程序存储库不支持 HTTPS，请将其设置为任何值（例如 `yes`），以允许脚本从不安全的 URL 下载文件。

`SKIP_DRIVER_LOADER`

如果您通过其他方式在主机上安装了驱动程序，很可能希望在容器启动时禁用 *falco-driver-loader* 脚本。在这种情况下，请将此环境变量设置为任何值（例如 `yes`）。此设置仅影响使用 *falco-driver-loader* 作为入口点的 Falco 容器镜像，例如 *falcosecurity/falco* 容器镜像。

`HOST_ROOT`

这个环境变量与这里列出的其他环境变量不同，它与驱动程序安装无关，直接影响 Falco。`HOST_ROOT` 期望一个基本路径，影响仪表盘的设置和增强系统。如果该值不为空，Falco 在访问主机文件系统时会将其用作路径前缀（例如 */dev* 下的内核模块设备或从 */proc* 和容器运行时 Unix 套接字路径中获取数据增强的信息）。*falco-driver-loader* 脚本也会为类似的目的使用这个变量（例如，访问 */boot*、*/lib*、*/usr* 和 */etc*）。

在容器中运行 Falco 时，请使用 `HOST_ROOT`。通常的约定是将 `HOST_ROOT=/host` 并将所有相关路径挂载到容器中的 */host* 目录下。Kubernetes 部署使用这种方法；详见第五章和第九章了解更多详情。

为了完整起见，与系统调用仪表盘相关的其他设置列在 Table 10-2 中。这些设置对性能有显著影响，因此除非必要，否则不要使用它们。

Table 10-2\. 系统调用仪表盘命令行选项

| Option | Description |
| --- | --- |
| `-A` | Falco 默认不监视所有系统调用，因此通常无法在规则条件中使用所有事件类型（驱动程序跳过大多数嘈杂或处理昂贵的系统调用，如 `read`、`write`、`send` 和 `recv`）。如果您启用此设置，驱动程序将发送所有支持的系统调用事件到 Falco，这在边缘用例中可能会有所帮助。但启用此设置会严重影响性能。Falco 可能无法跟上事件流。支持的系统调用完整列表可在 [*syscall_info_table.c*](https://oreil.ly/WVDRm) 中找到。默认情况下，驱动程序跳过那些标记为 `EF_DROP_SIMPLE_CONS` 的系统调用。 |
| `-u`, `--userspace` | 仅在无法使用内核空间工具时使用此选项。此选项必须与像 pdig（在 第四章 中讨论的用户空间驱动程序）一样使用。 |

## 数据丰富设置（仅系统调用）

使用系统调用作为数据源时，Falco 需要连接到驱动程序。它还需要从主机、容器运行时和 Kubernetes 获取信息。在 第五章 中，我们简要讨论了本节描述的设置；表 10-3 提供了影响数据丰富机制的命令行选项和环境变量的详细使用说明。

表 10-3\. 数据丰富命令行选项

| 选项 | 描述 |
| --- | --- |
| `--cri *<path>*` | 使用此选项指定 CRI 兼容容器运行时的 Unix 套接字路径。如果 Unix 套接字有效，Falco 将连接到运行时以获取容器元数据。在最新版本的 Falco 中，您可以多次指定此选项。Falco 将按顺序尝试每个给定的路径，并使用第一个连接成功的路径。如果未设置此选项，Falco 将仅尝试使用 */run/containerd/containerd.sock*。 |
| `--disable-cri-async` | 此选项禁用异步 CRI 元数据获取。通常不需要设置它。但如果 Falco 间歇性显示容器元数据，则此选项可以帮助您解决问题。 |
| `-k *<url>*`, `--k8s-api *<url>*` | 通过连接到由 `*<url>*` 指定的 Kubernetes API 服务器，启用 Kubernetes 元数据丰富。或者，您可以使用 `FALCO_K8S_API` 环境变量，它接受与此选项允许的相同值。 |
| `-K *<bt_file>* &#124; *<cert_file>*:*<key_file[#pwd]>* [:*<ca_cert_file>*]`, `--k8s-api-cert *<bt_file>* &#124; *<cert_file>*`:`*<key_file[#pwd]>* [:*<ca_cert_file>*]` | 使用此选项与 Kubernetes API 服务器进行身份验证。你可以提供一个令牌文件^(a) (`*<bt_file>*`) 或证书和私钥 (`*<cert_file>*`:`*<key_file>*`)。如果使用后者，你可以选择使用密码 (`*#pwd*`) 访问私钥（如果加密），以及 CA 证书 (`:*<ca_cert_file>*`) 用于验证 API 服务器的身份。证书和私钥必须以 PEM 文件格式提供。作为替代方案，你可以使用 `FALCO_K8S_API_CERT` 环境变量，该变量接受此选项允许的相同值。 |
| `--k8s-node *<node_name>*` | 此选项启用了 Kubernetes 元数据增强的重要性能优化：Falco 在从 API 服务器请求 Pod 的元数据时将使用节点名称作为过滤器，丢弃来自其他节点的不必要的元数据。你应该始终设置此选项。如果不设置，Falco 将工作，但在大型集群上可能存在性能问题。 |
| ^(a) 一个持有者令牌文件包含了用于验证 API 请求的字符串，这是 Kubernetes 的可用 [认证策略](https://oreil.ly/nh9Qk) 之一。 |

## 规则集设置

表 10-4 显示了可能影响规则集的命令行选项。如果没有使用这些选项，Falco 将仅使用配置文件来加载规则。

表 10-4\. 规则集命令行选项

| 选项 | 描述 |
| --- | --- |
| `-D *<substring>*` | 此选项允许你禁用其名称中匹配`*<substring>*`的一个或多个规则。你可以多次指定它，但与`-t`选项（见下文）不兼容。 |
| `-r *<rules_file>*` | 此选项允许你指定 Falco 用来加载规则的文件或目录。对于目录，Falco 将加载其中包含的所有文件。你可以多次指定 `-r` 来加载多个文件或目录。如果使用此选项，Falco 将忽略配置文件（*/etc/falco/falco.yaml*）中指定的规则文件和目录。因此，我们不建议在生产环境中使用它，除非用于调试或特殊情况。 |
| `-T *<tag>*` | 此选项禁用具有给定 `*<tag>*` 的所有规则。你可以多次指定它，但与 `-t` 选项不兼容（见下文）。 |
| `-t *<tag>*` | 此选项仅启用具有给定 `*<tag>*` 的规则，并禁用所有其他规则。你可以多次指定它，但与 `-T` 和 `-D` 选项不兼容。 |

## 输出设置

我们在 第 8 章 中描述了大部分的输出格式选项（以及 Falco 输出通道配置）。然而，还有另外两个命令行选项（列在 表 10-5 中），允许您进一步自定义 Falco 的输出行为。

表 10-5\. 输出命令行选项

| 选项 | 描述 |
| --- | --- |

| `-p*<output_format>*`, `--print*<output_format>*` | 启用时，此选项将额外信息附加到 Falco 通知的输出中。有几种不同的风格可用；例如：

+   `-pc` 或 `-pcontainer` 将添加容器信息，例如名称和 ID。

+   `-pk` 或 `-pkubernetes` 将添加 Kubernetes 信息，例如命名空间和 Pod 名称。

在 Kubernetes 环境中使用 Falco 时，我们建议使用 `-pk`。 |

| `-U`, `--unbuffered` | 此选项禁用输出通道中的完全输出缓冲（参见 第 8 章）。仅在将 Falco 输出导入另一个进程或脚本时遇到问题时使用。关闭输出缓冲可能会增加 CPU 使用率。 |
| --- | --- |

## 其他用于调试和故障排除的设置

迄今为止我们描述的命令行选项是您在操作 Falco 时可能经常使用的选项。但是，还有另一组选项（列在 表 10-6 中），用于更偶尔的使用，比如当您需要关于 Falco 安装的信息或尝试解决问题时。

表 10-6\. 调试和故障排除的命令行选项

| 选项 | 描述 |
| --- | --- |
| `-e *<events_file>*` | 告诉 Falco 使用由 `*<events_file>*` 指定的跟踪文件（参见 第 3 章）作为数据源，而不是使用实时事件源。一旦 Falco 消耗完文件中的所有事件，它就会退出。适用于测试和规则编写。 |
| `-L` | 打印有关所有加载的规则的信息。 |
| `-l *<rule>*` | 打印具有名称 `*<rule>*` 的规则的名称和描述（如果已加载）。 |
| `--list[=*<source>*]` | 按类别列出所有可用的条件字段（参见 第 6 章）。如果还提供 `*<source>*`，Falco 将仅列出该数据源的字段。`*<source>*` 的值可以是 `syscall` 或由已配置的插件提供的任何其他数据源。 |
| `--list-plugins` | 打印已配置插件的信息。 |
| `-s *<stats_file>*` | 告诉 Falco 创建文件 `*<stats_file>*` 并在运行时填充统计信息。 |
| `--stats-interval *<msec>*` | 设置更新由 `-s *<stats_file>*` 创建的文件的刷新间隔（以毫秒为单位）。 |
| `--support` | 打印有关加载的 Falco 配置和规则集以及其他有用的故障排除信息的详细信息，您在请求帮助时可以提供这些信息（例如，在 Falco GitHub 存储库中 [提交问题](https://oreil.ly/vkk2h)）。 |
| `-V`, `--validate *<rules_file>*` | 验证给定的 `*<rules_file>*` 内容。用于测试和规则编写。 |
| `-v` | 在 Falco 运行时启用详细日志记录。此选项不影响通常的 Falco 通知，但日志消息可能会交错。用于调试非常有用。 |
| `--version` | 打印您正在使用的 Falco 版本。 |

# 配置文件

在本书中，我们一直在讨论 Falco 的配置文件，并且已经涵盖了它的大部分重要方面。本节提供了一个概述和指向您可能需要的所有内容的指针。

默认情况下，配置文件是一个 YAML 文件，位于 */etc/falco/falco.yaml*。在此文件中，您可以配置：

规则文件

`rules_file` 配置节点是配置文件中第一个找到的节点。它允许您选择 Falco 将加载的规则文件（更多细节将在下一节介绍）。

插件

您可以通过 `load_plugins` 和 `plugins` 配置节点启用插件并传递设置（参见“使用插件”）。

输出通道

各种配置节点允许您配置格式化、日志记录和输出通道选项。有关输出框架的更多信息，请参阅第 8 章。

嵌入式服务器

Falco 提供了一个嵌入式 Web 服务器，公开了一个健康的端点。[³] 容器编排器和其他应用程序可以使用此端点检查 Falco 是否正在运行。`webserver` 配置节点允许您启用和配置服务器。

Falco 还提供了一个 gRPC 服务器，您可以使用 `grpc` 配置节点启用和配置它（参见第 8 和 12 章）。

高级调优设置（仅限系统调用）

系统调用仪器是 Falco 支持的最复杂功能之一，因此配置文件还提供了其高级设置。这些设置因 Falco 版本而异，因此我们建议您始终参考在线文档和配置文件中的内联注释。

在这里需要注意的选项包括 `syscall_event_drops`，用于控制事件丢弃的检测；`syscall_event_timeouts`，帮助检测事件缺失（对于系统调用来说是不常见的情况）；以及 `metadata_download`，提供了几个选项来微调从容器编排器 API 服务器下载信息。  

# 规则集

Falco 自带一组预定义的规则，您可以直接使用。然而，有很多理由尽可能定制您的规则集。默认的规则集旨在覆盖主要的攻击向量，但这些规则无法涵盖所有可能的情况。攻击机制始终在发展，因此您的规则集需要跟上这些变化。如果您希望达到最高级别的安全性，您需要一个根据特定环境定制的规则集。

定制规则的额外好处包括避免噪声误报和优化 Falco 的性能。出于所有这些原因，你需要学会如何正确配置规则集。

## 加载规则文件

有两种方式告诉 Falco 要加载哪些规则文件：通过命令行或配置文件。在命令行上，你可以使用 `-r` 标志指定规则文件。在配置文件中，将规则文件放在 `rules_file` 部分下。请注意，通过命令行设置的内容会优先于配置文件。出于这个原因，在生产环境中，我们建议仅通过配置文件加载规则文件。

无论你选择哪种方法，你都可以指定多个规则文件或目录。因此，你可以这样做：

```
$ falco -r path/to/my/rulefile1.yaml -r path/to/my/rulefile2.yaml
```

或者：

```
rules_file:
  - path/to/my/rulefile1.yaml
  - path/to/my/rulefile2.yaml
```

需要注意的是，规则文件会按照指定的顺序加载和解析。（当条目是目录时，Falco 会按字母顺序加载该目录中的每个文件。）这使得可以在后续文件中自定义规则、宏和列表（参见 第七章），这些定义在一个文件中。默认的 Falco 配置经过精心设计以利用这种机制。

让我们来看看随 Falco 一起提供的默认配置文件中的 `rules_file` 部分：

```
rules_file:
  - /etc/falco/falco_rules.yaml
  - /etc/falco/falco_rules.local.yaml
  - /etc/falco/rules.d
```

主规则文件 *falco_rules.yaml* 包含系统调用的规则，随后是名为 *falco_rules.local.yaml* 的文件。你应该在 *falco_rules.local.yaml* 中进行对 *falco_rules.yaml* 的修改。默认情况下，这个文件是空的，你可以在其中工作而不必担心污染主规则文件。根据需要，你可以创建其他本地文件。

通常，Falco 每个数据源提供一个规则文件。你可以使用这种方法或根据需要使用多个文件。只需记住加载顺序很重要。还要注意，Falco 只会加载与配置的数据源匹配的规则；所有其他规则将被忽略。这意味着你无需担心手动删除或禁用用于其他数据源的规则文件。

## 调整规则集

调整规则集最重要的一点是理解你的用例需要检测什么。这将帮助你决定哪些规则对你有用，哪些不需要。避免不必要的规则不仅可以增加性能（Falco 将使用更少的 CPU 资源），还可以减少误报。

一旦完成初步浏览，禁用你不感兴趣的规则（如 第七章 中描述）。我们不建议从规则文件中删除它们，除非你从头开始创建自己的规则文件。我们还建议定期评估你的规则集，因为随时间推移，你需要的规则会发生变化。

接下来，查看规则的条件。我们将在 第十三章 中详细介绍编写 Falco 规则的细节，但现在我们将提供两个一般评估 Falco 规则的指南。

首先，*避免在条件中使用过多的异常*，例如，长链条的`and not (...) and not (...)`。Falco 必须顺序检查条件中的任何异常，这是一项昂贵的任务。在可能的情况下，更短的条件可以显著改善规则评估性能。

第二条准则仅适用于系统调用，并且认为*规则条件应始终匹配一个事件类型或一小组事件类型*。例如，`evt.type=connect`和`evt.type in (open,openat,openat2)`都可以接受，但`evt.type!=execve`不可以，因为该过滤器将匹配除一个之外的所有事件类型，这太多了。Falco 通过事件类型对规则进行索引，以优化其内部评估过程；匹配太多事件类型的规则会使此索引变得低效。为了帮助规则作者发现此问题，Falco 对匹配所有事件类型的规则发出警告。

# 使用插件

默认情况下，Falco 配置为使用系统调用。如果你想使用插件作为数据源，请确保：

+   插件文件已经存在于*/usr/share/falco/plugins*中（一些插件已随 Falco 一起提供）；如果没有，你需要将其安装到该文件夹中。

+   插件的规则文件已准备好（我们建议将其放在*/etc/falco*下）。

+   你已经阅读了插件的文档，并理解了它需要哪些配置参数。

然后，准备 Falco 的配置文件以使用插件是一个三步骤的过程：选择正确的规则文件、配置插件并启用它。

为了说明这个过程，我们将使用[CloudTrail 插件](https://oreil.ly/kgImn)，它获取包含[CloudTrail](https://oreil.ly/DUEDJ)事件的日志文件（有关使用此插件的详细信息将在下一章提供）。CloudTrail 插件具有一个规则集，需要另一个具有字段提取能力的插件：[JSON 插件](https://oreil.ly/Viiaj)。这两个插件和规则集都与 Falco 捆绑在一起，所以如果你已经安装了 Falco，你应该已经拥有它们。你会在*/usr/share/falco/plugins*下找到插件文件*libcloudtrail.so*和*libjson.so*，规则文件在*/etc/falco/aws_cloudtrail_rules.yaml*。

插件的规则文件通常不会在 Falco 配置中默认配置，因此你需要添加一个`rules_file`条目来加载正确的规则文件（如果需要，也可以删除不必要的规则文件）：

```
rules_file:
  - /etc/falco/aws_cloudtrail_rules.yaml
```

接下来，在`plugins`下添加相关条目：

```
plugins:
  - name: cloudtrail
    library_path: libcloudtrail.so
    init_config:
      sqsDelete: true
    open_params: "sqs://my-sqs-queue"
  - name: json
    library_path: libjson.so
    init_config: ""
```

`name`字段必须与插件名称匹配，`library_path`必须与*/usr/share/falco/plugins*下的插件文件匹配。

在`init_config`中，添加 Falco 将传递给插件的初始化参数（有关详细信息，请参阅插件的文档）。大多数插件接受纯文本或 JSON 格式的字符串。如果插件支持 JSON 字符串，你仍然可以使用 YAML 语法来编写`init_config`（如前面的示例）；Falco 会自动为你进行转换。

`open_params`设置仅适用于具有事件源能力的插件（例如 CloudTrail 插件），并且仅接受纯文本字符串。它提供打开事件流的参数（再次参考插件的文档）。某些插件可能不需要此设置；在这种情况下，您可以将其设置为空字符串（`""`）。

最后一步是启用您的插件：

```
load_plugins: [cloudtrail, json]
```

`load_plugins`设置接受一个插件名称数组。您可以同时启用多个插件。

就这样！您的插件现在已配置并准备在 Falco 中运行。

# 修改配置

安装和配置 Falco 后，您可能需要不时地更改其配置。有两种方式告知 Falco 加载更新的配置（即配置文件或规则文件的任何修改）。

最简单的方法就是修改配置然后重新启动 Falco。如果您是通过包管理器在主机上安装的 Falco，您可以使用`systemctl restart falco`命令来实现这一点。如果您在容器中运行 Falco，则重新启动容器。如果您在 Kubernetes 集群中运行 Falco，则需要重新部署 Falco。重新启动 Falco 是升级到新版本或更改其命令行设置的唯一方法。

第二种加载更新配置的方式是*热重载*，即告诉 Falco 在不停止其运行进程的情况下重新加载配置和规则文件。您可以通过发送[SIGHUP 信号](https://oreil.ly/6unav)来告诉 Falco 自行重新加载：

```
$ kill -HUP *<falco process ID here>*
```

一旦 Falco 收到信号，它将重新加载配置文件和配置的规则文件。

自 0.32.0 版本以来，当修改配置文件或规则文件时，Falco 可以自动进行热重载。在配置文件中，`watch_config_files`设置控制此功能（默认启用）。因此，在最新版本的 Falco 中，您只需修改配置文件或规则文件，无需手动发送 SIGHUP 信号。

请注意，在 Falco 重新启动或热重载时，它不会检测事件。然而，与重新启动进程所需的时间相比，热重载 Falco 所需的时间显著缩短，通常可以忽略不计。

# 结论

本章和前一章深入讲解了在生产环境中安装、配置和运行 Falco 的各个方面，无论是系统调用仪器化场景还是使用插件作为数据源的场景。现在是深入探讨具体插件案例的时候了：如何利用 Falco 进行云安全。在下一章中，您将了解如何通过使用 CloudTrail 插件来保护您的云环境。

^(1) 在 Docker 运行容器时，还有几种设置环境变量的方法；更多信息请参阅 Docker 的[在线文档](https://oreil.ly/91H3j)。

^(2) 有几种方法可以将文件挂载到容器中。详细信息请参阅 Docker 的[文档](https://oreil.ly/4cdap)。

^(3) Falco 的开发人员最初引入了 Web 服务器来支持 Kubernetes 审计日志作为数据源。最近，他们将此功能因子分解为插件。因此，您可以在不同的 Falco 版本下的`webserver`配置节点中找到的实际设置可能会有很大差异。

^(4) 带有插件系统的 Falco 的首个版本不允许您同时启用具有事件源能力的多个插件。然而，您可以仅启用具有字段提取能力的多个插件（参见第四章）。
